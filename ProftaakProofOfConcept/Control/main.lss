
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000d18  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000022  00800060  00000d18  00000dac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000009b  00800082  00800082  00000dce  2**0
                  ALLOC
  3 .stab         00000954  00000000  00000000  00000dd0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000000b4  00000000  00000000  00001724  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000017d8  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000080  00000000  00000000  000017e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001b27  00000000  00000000  00001869  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000792  00000000  00000000  00003390  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000057d  00000000  00000000  00003b22  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000780  00000000  00000000  000040a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000085b  00000000  00000000  00004820  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000157e  00000000  00000000  0000507b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000010  00000000  00000000  000065f9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
   4:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__vector_1>
   8:	0c 94 8e 00 	jmp	0x11c	; 0x11c <__vector_2>
   c:	0c 94 ba 00 	jmp	0x174	; 0x174 <__vector_3>
  10:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  14:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  18:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  1c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  20:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  24:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  28:	0c 94 17 02 	jmp	0x42e	; 0x42e <__vector_10>
  2c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  30:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  34:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__vector_13>
  38:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  3c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  40:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  44:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  48:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  4c:	0c 94 9b 05 	jmp	0xb36	; 0xb36 <__vector_19>
  50:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>

00000054 <__c.2163>:
  54:	0a 0a 50 43 33 20 69 73 20 4c 4f 57 21 0a 0a 00     ..PC3 is LOW!...

00000064 <__c.2161>:
  64:	0a 0a 50 43 33 20 69 73 20 48 49 47 48 21 0a 0a     ..PC3 is HIGH!..
	...

00000076 <__ctors_end>:
  76:	11 24       	eor	r1, r1
  78:	1f be       	out	0x3f, r1	; 63
  7a:	cf e5       	ldi	r28, 0x5F	; 95
  7c:	d8 e0       	ldi	r29, 0x08	; 8
  7e:	de bf       	out	0x3e, r29	; 62
  80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
  82:	10 e0       	ldi	r17, 0x00	; 0
  84:	a0 e6       	ldi	r26, 0x60	; 96
  86:	b0 e0       	ldi	r27, 0x00	; 0
  88:	e8 e1       	ldi	r30, 0x18	; 24
  8a:	fd e0       	ldi	r31, 0x0D	; 13
  8c:	02 c0       	rjmp	.+4      	; 0x92 <__do_copy_data+0x10>
  8e:	05 90       	lpm	r0, Z+
  90:	0d 92       	st	X+, r0
  92:	a2 38       	cpi	r26, 0x82	; 130
  94:	b1 07       	cpc	r27, r17
  96:	d9 f7       	brne	.-10     	; 0x8e <__do_copy_data+0xc>

00000098 <__do_clear_bss>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a2 e8       	ldi	r26, 0x82	; 130
  9c:	b0 e0       	ldi	r27, 0x00	; 0
  9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
  a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
  a2:	ad 31       	cpi	r26, 0x1D	; 29
  a4:	b1 07       	cpc	r27, r17
  a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
  a8:	0e 94 14 06 	call	0xc28	; 0xc28 <main>
  ac:	0c 94 8a 06 	jmp	0xd14	; 0xd14 <_exit>

000000b0 <__bad_interrupt>:
  b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b4 <INT0_event_DUMMY>:
// Event Handlers. 
// Please make sure that you keep the Event Handler Functions as
// short as possible! 
// --> You usually don't need this stuff. 

void INT0_event_DUMMY(void){}
  b4:	08 95       	ret

000000b6 <INT1_event_DUMMY>:
ISR (INT0_vect)
{
	INT0_eventHandler();
}

void INT1_event_DUMMY(void){}
  b6:	08 95       	ret

000000b8 <INT2_event_DUMMY>:
ISR (INT1_vect)
{
	INT1_eventHandler();
}

void INT2_event_DUMMY(void){}
  b8:	08 95       	ret

000000ba <INT0_setEventHandler>:

void INT0_event_DUMMY(void){}
static void (*INT0_eventHandler)(void) = INT0_event_DUMMY;
void INT0_setEventHandler(void (*i0eventHandler)(void))
{
	INT0_eventHandler = i0eventHandler;
  ba:	90 93 65 00 	sts	0x0065, r25
  be:	80 93 64 00 	sts	0x0064, r24
  c2:	08 95       	ret

000000c4 <__vector_1>:

/**
 * External Interrupt 0 ISR
 */
ISR (INT0_vect)
{
  c4:	1f 92       	push	r1
  c6:	0f 92       	push	r0
  c8:	0f b6       	in	r0, 0x3f	; 63
  ca:	0f 92       	push	r0
  cc:	11 24       	eor	r1, r1
  ce:	2f 93       	push	r18
  d0:	3f 93       	push	r19
  d2:	4f 93       	push	r20
  d4:	5f 93       	push	r21
  d6:	6f 93       	push	r22
  d8:	7f 93       	push	r23
  da:	8f 93       	push	r24
  dc:	9f 93       	push	r25
  de:	af 93       	push	r26
  e0:	bf 93       	push	r27
  e2:	ef 93       	push	r30
  e4:	ff 93       	push	r31
	INT0_eventHandler();
  e6:	e0 91 64 00 	lds	r30, 0x0064
  ea:	f0 91 65 00 	lds	r31, 0x0065
  ee:	09 95       	icall
}
  f0:	ff 91       	pop	r31
  f2:	ef 91       	pop	r30
  f4:	bf 91       	pop	r27
  f6:	af 91       	pop	r26
  f8:	9f 91       	pop	r25
  fa:	8f 91       	pop	r24
  fc:	7f 91       	pop	r23
  fe:	6f 91       	pop	r22
 100:	5f 91       	pop	r21
 102:	4f 91       	pop	r20
 104:	3f 91       	pop	r19
 106:	2f 91       	pop	r18
 108:	0f 90       	pop	r0
 10a:	0f be       	out	0x3f, r0	; 63
 10c:	0f 90       	pop	r0
 10e:	1f 90       	pop	r1
 110:	18 95       	reti

00000112 <INT1_setEventHandler>:

void INT1_event_DUMMY(void){}
static void (*INT1_eventHandler)(void) = INT1_event_DUMMY;
void INT1_setEventHandler(void (*i1eventHandler)(void))
{
	INT1_eventHandler = i1eventHandler;
 112:	90 93 63 00 	sts	0x0063, r25
 116:	80 93 62 00 	sts	0x0062, r24
 11a:	08 95       	ret

0000011c <__vector_2>:

/**
 * External Interrupt 1 ISR
 */
ISR (INT1_vect)
{
 11c:	1f 92       	push	r1
 11e:	0f 92       	push	r0
 120:	0f b6       	in	r0, 0x3f	; 63
 122:	0f 92       	push	r0
 124:	11 24       	eor	r1, r1
 126:	2f 93       	push	r18
 128:	3f 93       	push	r19
 12a:	4f 93       	push	r20
 12c:	5f 93       	push	r21
 12e:	6f 93       	push	r22
 130:	7f 93       	push	r23
 132:	8f 93       	push	r24
 134:	9f 93       	push	r25
 136:	af 93       	push	r26
 138:	bf 93       	push	r27
 13a:	ef 93       	push	r30
 13c:	ff 93       	push	r31
	INT1_eventHandler();
 13e:	e0 91 62 00 	lds	r30, 0x0062
 142:	f0 91 63 00 	lds	r31, 0x0063
 146:	09 95       	icall
}
 148:	ff 91       	pop	r31
 14a:	ef 91       	pop	r30
 14c:	bf 91       	pop	r27
 14e:	af 91       	pop	r26
 150:	9f 91       	pop	r25
 152:	8f 91       	pop	r24
 154:	7f 91       	pop	r23
 156:	6f 91       	pop	r22
 158:	5f 91       	pop	r21
 15a:	4f 91       	pop	r20
 15c:	3f 91       	pop	r19
 15e:	2f 91       	pop	r18
 160:	0f 90       	pop	r0
 162:	0f be       	out	0x3f, r0	; 63
 164:	0f 90       	pop	r0
 166:	1f 90       	pop	r1
 168:	18 95       	reti

0000016a <INT2_setEventHandler>:

void INT2_event_DUMMY(void){}
static void (*INT2_eventHandler)(void) = INT2_event_DUMMY;
void INT2_setEventHandler(void (*i2eventHandler)(void))
{
	INT2_eventHandler = i2eventHandler;
 16a:	90 93 61 00 	sts	0x0061, r25
 16e:	80 93 60 00 	sts	0x0060, r24
 172:	08 95       	ret

00000174 <__vector_3>:

/**
 * External Interrupt 2 ISR
 */
ISR (INT2_vect)
{
 174:	1f 92       	push	r1
 176:	0f 92       	push	r0
 178:	0f b6       	in	r0, 0x3f	; 63
 17a:	0f 92       	push	r0
 17c:	11 24       	eor	r1, r1
 17e:	2f 93       	push	r18
 180:	3f 93       	push	r19
 182:	4f 93       	push	r20
 184:	5f 93       	push	r21
 186:	6f 93       	push	r22
 188:	7f 93       	push	r23
 18a:	8f 93       	push	r24
 18c:	9f 93       	push	r25
 18e:	af 93       	push	r26
 190:	bf 93       	push	r27
 192:	ef 93       	push	r30
 194:	ff 93       	push	r31
	INT2_eventHandler();
 196:	e0 91 60 00 	lds	r30, 0x0060
 19a:	f0 91 61 00 	lds	r31, 0x0061
 19e:	09 95       	icall
}
 1a0:	ff 91       	pop	r31
 1a2:	ef 91       	pop	r30
 1a4:	bf 91       	pop	r27
 1a6:	af 91       	pop	r26
 1a8:	9f 91       	pop	r25
 1aa:	8f 91       	pop	r24
 1ac:	7f 91       	pop	r23
 1ae:	6f 91       	pop	r22
 1b0:	5f 91       	pop	r21
 1b2:	4f 91       	pop	r20
 1b4:	3f 91       	pop	r19
 1b6:	2f 91       	pop	r18
 1b8:	0f 90       	pop	r0
 1ba:	0f be       	out	0x3f, r0	; 63
 1bc:	0f 90       	pop	r0
 1be:	1f 90       	pop	r1
 1c0:	18 95       	reti

000001c2 <readADC>:
 * is complete. 
 *
 */
uint16_t readADC(uint8_t channel)
{
	if((ADCSRA & (1<<ADSC))) return 0; // check if ADC is buisy...
 1c2:	36 99       	sbic	0x06, 6	; 6
 1c4:	0a c0       	rjmp	.+20     	; 0x1da <readADC+0x18>
	ADMUX = (1<<REFS0) | (0<<REFS1) | (channel<<MUX0);
 1c6:	80 64       	ori	r24, 0x40	; 64
 1c8:	87 b9       	out	0x07, r24	; 7
	ADCSRA = (0<<ADIE) | (1<<ADSC) | (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADIF);
 1ca:	86 ed       	ldi	r24, 0xD6	; 214
 1cc:	86 b9       	out	0x06, r24	; 6
	while ((ADCSRA & (1<<ADSC))); 
 1ce:	36 99       	sbic	0x06, 6	; 6
 1d0:	fe cf       	rjmp	.-4      	; 0x1ce <readADC+0xc>
	ADCSRA |= (1<<ADIF);
 1d2:	34 9a       	sbi	0x06, 4	; 6
	return ADC;
 1d4:	84 b1       	in	r24, 0x04	; 4
 1d6:	95 b1       	in	r25, 0x05	; 5
 1d8:	08 95       	ret
 * is complete. 
 *
 */
uint16_t readADC(uint8_t channel)
{
	if((ADCSRA & (1<<ADSC))) return 0; // check if ADC is buisy...
 1da:	80 e0       	ldi	r24, 0x00	; 0
 1dc:	90 e0       	ldi	r25, 0x00	; 0
	ADMUX = (1<<REFS0) | (0<<REFS1) | (channel<<MUX0);
	ADCSRA = (0<<ADIE) | (1<<ADSC) | (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADIF);
	while ((ADCSRA & (1<<ADSC))); 
	ADCSRA |= (1<<ADIF);
	return ADC;
}
 1de:	08 95       	ret

000001e0 <writeSPI>:
/**
 * Writes a single Databyte to the SPI Interface.
 */
void writeSPI(uint8_t data) 
{     
	SPDR = data;    
 1e0:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));
 1e2:	77 9b       	sbis	0x0e, 7	; 14
 1e4:	fe cf       	rjmp	.-4      	; 0x1e2 <writeSPI+0x2>
}
 1e6:	08 95       	ret

000001e8 <readSPI>:
/**
 * Reads a single Databyte from the SPI Interface.
 */
uint8_t readSPI(void)
{
	writeSPI(0xFF);
 1e8:	8f ef       	ldi	r24, 0xFF	; 255
 1ea:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	return SPDR;
 1ee:	8f b1       	in	r24, 0x0f	; 15
}
 1f0:	08 95       	ret

000001f2 <readWordSPI>:
/**
 * Reads TWO Bytes from the SPI Interface and returns them as
 * a 16 Bit value with first byte read in the upper 8 bits.
 */
uint16_t readWordSPI(void)
{
 1f2:	cf 93       	push	r28
 1f4:	df 93       	push	r29
	uint16_t data = 0;
	data = readSPI() << 8;
 1f6:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <readSPI>
 1fa:	c8 2f       	mov	r28, r24
 1fc:	d0 e0       	ldi	r29, 0x00	; 0
 1fe:	dc 2f       	mov	r29, r28
 200:	cc 27       	eor	r28, r28
	data |= readSPI();
 202:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <readSPI>
	return data;
}
 206:	9e 01       	movw	r18, r28
 208:	28 2b       	or	r18, r24
 20a:	c9 01       	movw	r24, r18
 20c:	df 91       	pop	r29
 20e:	cf 91       	pop	r28
 210:	08 95       	ret

00000212 <writeWordSPI>:
/**
 * Writes two Bytes contained in the 16 Bit parameter "data".
 * The first byte to be written needs to be in the upper 8 Bits.
 */
void writeWordSPI(uint16_t data)
{
 212:	cf 93       	push	r28
 214:	c8 2f       	mov	r28, r24
	writeSPI((uint8_t)(data >> 8));
 216:	89 2f       	mov	r24, r25
 218:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	writeSPI((uint8_t)data);
 21c:	8c 2f       	mov	r24, r28
}
 21e:	cf 91       	pop	r28
 * The first byte to be written needs to be in the upper 8 Bits.
 */
void writeWordSPI(uint16_t data)
{
	writeSPI((uint8_t)(data >> 8));
	writeSPI((uint8_t)data);
 220:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <writeSPI>

00000224 <writeBufferSPI>:
 * This function writes up to 255 Bytes to the SPI Interface.
 * The numer of bytes in the Buffer that shall be written is given 
 * by the parameter length.
 */
void writeBufferSPI(uint8_t *buffer, uint8_t length)
{
 224:	28 2f       	mov	r18, r24
	uint8_t i = 0;
	for(; i < length; i++) {
 226:	fc 01       	movw	r30, r24
 228:	8e 2f       	mov	r24, r30
 22a:	82 1b       	sub	r24, r18
 22c:	86 17       	cp	r24, r22
 22e:	28 f4       	brcc	.+10     	; 0x23a <writeBufferSPI+0x16>
		SPDR = buffer[i];    
 230:	81 91       	ld	r24, Z+
 232:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)));
 234:	77 9b       	sbis	0x0e, 7	; 14
 236:	fe cf       	rjmp	.-4      	; 0x234 <writeBufferSPI+0x10>
 238:	f7 cf       	rjmp	.-18     	; 0x228 <writeBufferSPI+0x4>
	}
}
 23a:	08 95       	ret

0000023c <readBufferSPI>:

/** 
 * Reads "length" Bytes from SPI Interface into the buffer.
 */
void readBufferSPI(uint8_t *buffer, uint8_t length)
{
 23c:	28 2f       	mov	r18, r24
	uint8_t i = 0;
	for(; i < length; i++) {
 23e:	fc 01       	movw	r30, r24
		SPDR = 0xFF;    
 240:	9f ef       	ldi	r25, 0xFF	; 255
 242:	8e 2f       	mov	r24, r30
 244:	82 1b       	sub	r24, r18
 * Reads "length" Bytes from SPI Interface into the buffer.
 */
void readBufferSPI(uint8_t *buffer, uint8_t length)
{
	uint8_t i = 0;
	for(; i < length; i++) {
 246:	86 17       	cp	r24, r22
 248:	30 f4       	brcc	.+12     	; 0x256 <readBufferSPI+0x1a>
		SPDR = 0xFF;    
 24a:	9f b9       	out	0x0f, r25	; 15
		while(!(SPSR & (1<<SPIF)));
 24c:	77 9b       	sbis	0x0e, 7	; 14
 24e:	fe cf       	rjmp	.-4      	; 0x24c <readBufferSPI+0x10>
		buffer[i] = SPDR;
 250:	8f b1       	in	r24, 0x0f	; 15
 252:	81 93       	st	Z+, r24
 254:	f6 cf       	rjmp	.-20     	; 0x242 <readBufferSPI+0x6>
	}
}
 256:	08 95       	ret

00000258 <SPI_EEPROM_readByte>:

/**
 * Reads a single Byte from the external EEPROM.
 */
uint8_t SPI_EEPROM_readByte(uint16_t memAddr)
{
 258:	cf 93       	push	r28
 25a:	df 93       	push	r29
 25c:	ec 01       	movw	r28, r24
	uint8_t data;
	PORTB &= ~MEM_CS;
 25e:	c0 98       	cbi	0x18, 0	; 24
	writeSPI(SPI_EEPROM_READ);
 260:	83 e0       	ldi	r24, 0x03	; 3
 262:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	writeWordSPI(memAddr);
 266:	ce 01       	movw	r24, r28
 268:	0e 94 09 01 	call	0x212	; 0x212 <writeWordSPI>
	data = readSPI();
 26c:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <readSPI>
	PORTB |= MEM_CS;
 270:	c0 9a       	sbi	0x18, 0	; 24
	return data;
}
 272:	df 91       	pop	r29
 274:	cf 91       	pop	r28
 276:	08 95       	ret

00000278 <SPI_EEPROM_readBytes>:
 * Reads "length" Bytes into the Buffer "buffer" from startAdr on. 
 * You can read the complete EEPROM into a buffer at once - if it is large enough. 
 * (But you only have 2KB SRAM on a MEGA32 ;) )
 */
void SPI_EEPROM_readBytes(uint16_t startAddr, uint8_t *buffer, uint8_t length)
{
 278:	ef 92       	push	r14
 27a:	ff 92       	push	r15
 27c:	0f 93       	push	r16
 27e:	1f 93       	push	r17
 280:	cf 93       	push	r28
 282:	df 93       	push	r29
 284:	1f 92       	push	r1
 286:	cd b7       	in	r28, 0x3d	; 61
 288:	de b7       	in	r29, 0x3e	; 62
 28a:	7c 01       	movw	r14, r24
 28c:	8b 01       	movw	r16, r22
	PORTB &= ~MEM_CS;
 28e:	c0 98       	cbi	0x18, 0	; 24
	writeSPI(SPI_EEPROM_READ);
 290:	83 e0       	ldi	r24, 0x03	; 3
 292:	49 83       	std	Y+1, r20	; 0x01
 294:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	writeWordSPI(startAddr);
 298:	c7 01       	movw	r24, r14
 29a:	0e 94 09 01 	call	0x212	; 0x212 <writeWordSPI>
	readBufferSPI(&buffer[0], length);
 29e:	49 81       	ldd	r20, Y+1	; 0x01
 2a0:	64 2f       	mov	r22, r20
 2a2:	c8 01       	movw	r24, r16
 2a4:	0e 94 1e 01 	call	0x23c	; 0x23c <readBufferSPI>
	PORTB |= MEM_CS;
 2a8:	c0 9a       	sbi	0x18, 0	; 24
}
 2aa:	0f 90       	pop	r0
 2ac:	df 91       	pop	r29
 2ae:	cf 91       	pop	r28
 2b0:	1f 91       	pop	r17
 2b2:	0f 91       	pop	r16
 2b4:	ff 90       	pop	r15
 2b6:	ef 90       	pop	r14
 2b8:	08 95       	ret

000002ba <SPI_EEPROM_enableWrite>:
/**
 * Enable Write Mode
 */
void SPI_EEPROM_enableWrite(void)
{
	PORTB &= ~MEM_CS;
 2ba:	c0 98       	cbi	0x18, 0	; 24
	writeSPI(SPI_EEPROM_WREN);
 2bc:	86 e0       	ldi	r24, 0x06	; 6
 2be:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	PORTB |= MEM_CS;
 2c2:	c0 9a       	sbi	0x18, 0	; 24
 2c4:	08 95       	ret

000002c6 <SPI_EEPROM_disableWrite>:
/**
 * Disable Write Mode
 */
void SPI_EEPROM_disableWrite(void)
{
	PORTB &= ~MEM_CS;
 2c6:	c0 98       	cbi	0x18, 0	; 24
	writeSPI(SPI_EEPROM_WRDI);
 2c8:	84 e0       	ldi	r24, 0x04	; 4
 2ca:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	PORTB |= MEM_CS;
 2ce:	c0 9a       	sbi	0x18, 0	; 24
 2d0:	08 95       	ret

000002d2 <SPI_EEPROM_getStatus>:
 * Writing takes about 5ms. 
 */
uint8_t SPI_EEPROM_getStatus(void)
{
	uint8_t status;
	PORTB &= ~MEM_CS;
 2d2:	c0 98       	cbi	0x18, 0	; 24
	writeSPI(SPI_EEPROM_RDSR);
 2d4:	85 e0       	ldi	r24, 0x05	; 5
 2d6:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	status = readSPI();
 2da:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <readSPI>
	PORTB |= MEM_CS;
 2de:	c0 9a       	sbi	0x18, 0	; 24
	return status;
}
 2e0:	08 95       	ret

000002e2 <SPI_EEPROM_writeByte>:

/**
 * Write a single data byte to the specified EEPROM address.
 */
void SPI_EEPROM_writeByte(uint16_t memAddr, uint8_t data)
{
 2e2:	1f 93       	push	r17
 2e4:	cf 93       	push	r28
 2e6:	df 93       	push	r29
 2e8:	ec 01       	movw	r28, r24
 2ea:	16 2f       	mov	r17, r22
	while(SPI_EEPROM_getStatus() & SPI_EEPROM_STAT_WIP);
 2ec:	0e 94 69 01 	call	0x2d2	; 0x2d2 <SPI_EEPROM_getStatus>
 2f0:	80 fd       	sbrc	r24, 0
 2f2:	fc cf       	rjmp	.-8      	; 0x2ec <SPI_EEPROM_writeByte+0xa>
	SPI_EEPROM_enableWrite();
 2f4:	0e 94 5d 01 	call	0x2ba	; 0x2ba <SPI_EEPROM_enableWrite>
	PORTB &= ~MEM_CS;
 2f8:	c0 98       	cbi	0x18, 0	; 24
	writeSPI(SPI_EEPROM_WRITE);
 2fa:	82 e0       	ldi	r24, 0x02	; 2
 2fc:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	writeWordSPI(memAddr);
 300:	ce 01       	movw	r24, r28
 302:	0e 94 09 01 	call	0x212	; 0x212 <writeWordSPI>
	writeSPI(data);
 306:	81 2f       	mov	r24, r17
 308:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	PORTB |= MEM_CS;
 30c:	c0 9a       	sbi	0x18, 0	; 24
}
 30e:	df 91       	pop	r29
 310:	cf 91       	pop	r28
 312:	1f 91       	pop	r17
 314:	08 95       	ret

00000316 <SPI_EEPROM_writeBytes>:
 * instead only up to 63 and then it continues at Byte 0 and writes 
 * the rest up to Byte 10!
 *
 */
void SPI_EEPROM_writeBytes(uint16_t startAddr, uint8_t *buffer, uint8_t length)
{
 316:	ff 92       	push	r15
 318:	0f 93       	push	r16
 31a:	1f 93       	push	r17
 31c:	cf 93       	push	r28
 31e:	df 93       	push	r29
 320:	ec 01       	movw	r28, r24
 322:	8b 01       	movw	r16, r22
 324:	f4 2e       	mov	r15, r20
	while(SPI_EEPROM_getStatus() & SPI_EEPROM_STAT_WIP);
 326:	0e 94 69 01 	call	0x2d2	; 0x2d2 <SPI_EEPROM_getStatus>
 32a:	80 fd       	sbrc	r24, 0
 32c:	fc cf       	rjmp	.-8      	; 0x326 <SPI_EEPROM_writeBytes+0x10>
	SPI_EEPROM_enableWrite();
 32e:	0e 94 5d 01 	call	0x2ba	; 0x2ba <SPI_EEPROM_enableWrite>
	PORTB &= ~MEM_CS;
 332:	c0 98       	cbi	0x18, 0	; 24
	writeSPI(SPI_EEPROM_WRITE);
 334:	82 e0       	ldi	r24, 0x02	; 2
 336:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
	writeWordSPI(startAddr);
 33a:	ce 01       	movw	r24, r28
 33c:	0e 94 09 01 	call	0x212	; 0x212 <writeWordSPI>
	writeBufferSPI(&buffer[0], length);
 340:	6f 2d       	mov	r22, r15
 342:	c8 01       	movw	r24, r16
 344:	0e 94 12 01 	call	0x224	; 0x224 <writeBufferSPI>
	PORTB |= MEM_CS;
 348:	c0 9a       	sbi	0x18, 0	; 24
}
 34a:	df 91       	pop	r29
 34c:	cf 91       	pop	r28
 34e:	1f 91       	pop	r17
 350:	0f 91       	pop	r16
 352:	ff 90       	pop	r15
 354:	08 95       	ret

00000356 <outputExt>:
 * in 4 or 8bit mode - we use 4bit mode to save portpins) 
 *
 */
void outputExt(void)
{      
  writeSPI(externalPort.byte);   
 356:	80 91 b5 00 	lds	r24, 0x00B5
 35a:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <writeSPI>
  PORTD |= STR;
 35e:	94 9a       	sbi	0x12, 4	; 18
  nop();
 360:	00 00       	nop
  nop();
 362:	00 00       	nop
  PORTD &= ~STR;        
 364:	94 98       	cbi	0x12, 4	; 18
 366:	08 95       	ret

00000368 <setLEDs>:
 * are connected to the LCD! 
 *
 */
void setLEDs(uint8_t leds)
{
	externalPort.LEDS = leds;
 368:	8f 70       	andi	r24, 0x0F	; 15
 36a:	90 91 b5 00 	lds	r25, 0x00B5
 36e:	90 7f       	andi	r25, 0xF0	; 240
 370:	98 2b       	or	r25, r24
 372:	90 93 b5 00 	sts	0x00B5, r25
	outputExt();
 376:	0c 94 ab 01 	jmp	0x356	; 0x356 <outputExt>

0000037a <getPressedKeyNumber>:
 * Maybe you need to adjust these values because of variations
 * in the resitors of the keypad!
 *
 */
uint8_t getPressedKeyNumber(void)
{
 37a:	cf 93       	push	r28
 37c:	df 93       	push	r29
	uint16_t keys;
	keys = readADC(ADC_KEYPAD);
 37e:	81 e0       	ldi	r24, 0x01	; 1
 380:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <readADC>
 384:	ec 01       	movw	r28, r24
	if(keys < 1020) {
 386:	cc 3f       	cpi	r28, 0xFC	; 252
 388:	83 e0       	ldi	r24, 0x03	; 3
 38a:	d8 07       	cpc	r29, r24
 38c:	88 f4       	brcc	.+34     	; 0x3b0 <getPressedKeyNumber+0x36>
		nop();
 38e:	00 00       	nop
		nop();
 390:	00 00       	nop
		nop();
 392:	00 00       	nop
		keys += readADC(ADC_KEYPAD);
 394:	81 e0       	ldi	r24, 0x01	; 1
 396:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <readADC>
 39a:	c8 0f       	add	r28, r24
 39c:	d9 1f       	adc	r29, r25
		keys >>= 1;
 39e:	d6 95       	lsr	r29
 3a0:	c7 95       	ror	r28
	}
	if(keys < 50)
 3a2:	c2 33       	cpi	r28, 0x32	; 50
 3a4:	d1 05       	cpc	r29, r1
 3a6:	88 f0       	brcs	.+34     	; 0x3ca <getPressedKeyNumber+0x50>
		return 1;
	if(keys < 580)
 3a8:	c4 34       	cpi	r28, 0x44	; 68
 3aa:	82 e0       	ldi	r24, 0x02	; 2
 3ac:	d8 07       	cpc	r29, r24
 3ae:	78 f0       	brcs	.+30     	; 0x3ce <getPressedKeyNumber+0x54>
		return 2;
	if(keys < 700)
 3b0:	cc 3b       	cpi	r28, 0xBC	; 188
 3b2:	82 e0       	ldi	r24, 0x02	; 2
 3b4:	d8 07       	cpc	r29, r24
 3b6:	68 f0       	brcs	.+26     	; 0x3d2 <getPressedKeyNumber+0x58>
		return 3;
	if(keys < 790)
 3b8:	c6 31       	cpi	r28, 0x16	; 22
 3ba:	83 e0       	ldi	r24, 0x03	; 3
 3bc:	d8 07       	cpc	r29, r24
 3be:	58 f0       	brcs	.+22     	; 0x3d6 <getPressedKeyNumber+0x5c>
		return 4;
	if(keys < 830)
 3c0:	ce 33       	cpi	r28, 0x3E	; 62
 3c2:	d3 40       	sbci	r29, 0x03	; 3
 3c4:	50 f4       	brcc	.+20     	; 0x3da <getPressedKeyNumber+0x60>
		return 5;
 3c6:	85 e0       	ldi	r24, 0x05	; 5
 3c8:	09 c0       	rjmp	.+18     	; 0x3dc <getPressedKeyNumber+0x62>
		nop();
		keys += readADC(ADC_KEYPAD);
		keys >>= 1;
	}
	if(keys < 50)
		return 1;
 3ca:	81 e0       	ldi	r24, 0x01	; 1
 3cc:	07 c0       	rjmp	.+14     	; 0x3dc <getPressedKeyNumber+0x62>
	if(keys < 580)
		return 2;
 3ce:	82 e0       	ldi	r24, 0x02	; 2
 3d0:	05 c0       	rjmp	.+10     	; 0x3dc <getPressedKeyNumber+0x62>
	if(keys < 700)
		return 3;
 3d2:	83 e0       	ldi	r24, 0x03	; 3
 3d4:	03 c0       	rjmp	.+6      	; 0x3dc <getPressedKeyNumber+0x62>
	if(keys < 790)
		return 4;
 3d6:	84 e0       	ldi	r24, 0x04	; 4
 3d8:	01 c0       	rjmp	.+2      	; 0x3dc <getPressedKeyNumber+0x62>
	if(keys < 830)
		return 5;
	return 0;
 3da:	80 e0       	ldi	r24, 0x00	; 0
}
 3dc:	df 91       	pop	r29
 3de:	cf 91       	pop	r28
 3e0:	08 95       	ret

000003e2 <checkPressedKeyEvent>:
 * to be released again!
 */
uint8_t checkPressedKeyEvent(void)
{
	static uint8_t pressed_key = 0;
	if(pressed_key) {
 3e2:	80 91 83 00 	lds	r24, 0x0083
 3e6:	88 23       	and	r24, r24
 3e8:	39 f0       	breq	.+14     	; 0x3f8 <checkPressedKeyEvent+0x16>
		if(!getPressedKeyNumber()) 
 3ea:	0e 94 bd 01 	call	0x37a	; 0x37a <getPressedKeyNumber>
 3ee:	81 11       	cpse	r24, r1
 3f0:	08 c0       	rjmp	.+16     	; 0x402 <checkPressedKeyEvent+0x20>
			pressed_key = 0;
 3f2:	10 92 83 00 	sts	0x0083, r1
 3f6:	08 95       	ret
	}
	else {
		pressed_key = getPressedKeyNumber();
 3f8:	0e 94 bd 01 	call	0x37a	; 0x37a <getPressedKeyNumber>
 3fc:	80 93 83 00 	sts	0x0083, r24
 400:	08 95       	ret
		if(pressed_key)
			return pressed_key;
	}
	return 0;
 402:	80 e0       	ldi	r24, 0x00	; 0
}
 404:	08 95       	ret

00000406 <checkReleasedKeyEvent>:
 * main loop. You don't need something like 
 * "while(getPressedKeyNumber());" to wait for the button
 * to be released again!
 */
uint8_t checkReleasedKeyEvent(void)
{
 406:	cf 93       	push	r28
	static uint8_t released_key = 0;
	if(released_key) {
 408:	c0 91 82 00 	lds	r28, 0x0082
 40c:	cc 23       	and	r28, r28
 40e:	41 f0       	breq	.+16     	; 0x420 <checkReleasedKeyEvent+0x1a>
		if(!getPressedKeyNumber()) {
 410:	0e 94 bd 01 	call	0x37a	; 0x37a <getPressedKeyNumber>
 414:	81 11       	cpse	r24, r1
 416:	08 c0       	rjmp	.+16     	; 0x428 <checkReleasedKeyEvent+0x22>
			uint8_t tmp = released_key;
			released_key = 0;
 418:	10 92 82 00 	sts	0x0082, r1
			return tmp;
 41c:	8c 2f       	mov	r24, r28
 41e:	05 c0       	rjmp	.+10     	; 0x42a <checkReleasedKeyEvent+0x24>
		}
	}
	else
		released_key = getPressedKeyNumber();
 420:	0e 94 bd 01 	call	0x37a	; 0x37a <getPressedKeyNumber>
 424:	80 93 82 00 	sts	0x0082, r24
	return 0;
 428:	80 e0       	ldi	r24, 0x00	; 0
}
 42a:	cf 91       	pop	r28
 42c:	08 95       	ret

0000042e <__vector_10>:
 *
 * By default, it runs at 10kHz which means this ISR is called
 * every ~100탎! This is nice for timing stuff!
 */
ISR (TIMER0_COMP_vect)
{
 42e:	1f 92       	push	r1
 430:	0f 92       	push	r0
 432:	0f b6       	in	r0, 0x3f	; 63
 434:	0f 92       	push	r0
 436:	11 24       	eor	r1, r1
 438:	8f 93       	push	r24
 43a:	9f 93       	push	r25
	// 16bit timer (100탎 resolution)
	timer++;
 43c:	80 91 90 00 	lds	r24, 0x0090
 440:	90 91 91 00 	lds	r25, 0x0091
 444:	01 96       	adiw	r24, 0x01	; 1
 446:	90 93 91 00 	sts	0x0091, r25
 44a:	80 93 90 00 	sts	0x0090, r24
	
	// Blocking delay (100탎):
	delay_timer++;
 44e:	80 91 b6 00 	lds	r24, 0x00B6
 452:	8f 5f       	subi	r24, 0xFF	; 255
 454:	80 93 b6 00 	sts	0x00B6, r24
	
	// All 1ms based timing stuff
	if(ms_timer++ >= 9) { // 10 * 100탎 = 1ms, >= 9 because 0..9 = 10 counts
 458:	80 91 b7 00 	lds	r24, 0x00B7
 45c:	91 e0       	ldi	r25, 0x01	; 1
 45e:	98 0f       	add	r25, r24
 460:	90 93 b7 00 	sts	0x00B7, r25
 464:	89 30       	cpi	r24, 0x09	; 9
 466:	08 f4       	brcc	.+2      	; 0x46a <__vector_10+0x3c>
 468:	84 c0       	rjmp	.+264    	; 0x572 <__vector_10+0x144>
		// 16bit Stopwatches:
		if(stopwatches.watches & STOPWATCH1)
 46a:	80 91 a4 00 	lds	r24, 0x00A4
 46e:	80 ff       	sbrs	r24, 0
 470:	09 c0       	rjmp	.+18     	; 0x484 <__vector_10+0x56>
			stopwatches.watch1++;
 472:	80 91 a5 00 	lds	r24, 0x00A5
 476:	90 91 a6 00 	lds	r25, 0x00A6
 47a:	01 96       	adiw	r24, 0x01	; 1
 47c:	90 93 a6 00 	sts	0x00A6, r25
 480:	80 93 a5 00 	sts	0x00A5, r24
		if(stopwatches.watches & STOPWATCH2)
 484:	80 91 a4 00 	lds	r24, 0x00A4
 488:	81 ff       	sbrs	r24, 1
 48a:	09 c0       	rjmp	.+18     	; 0x49e <__vector_10+0x70>
			stopwatches.watch2++;
 48c:	80 91 a7 00 	lds	r24, 0x00A7
 490:	90 91 a8 00 	lds	r25, 0x00A8
 494:	01 96       	adiw	r24, 0x01	; 1
 496:	90 93 a8 00 	sts	0x00A8, r25
 49a:	80 93 a7 00 	sts	0x00A7, r24
		if(stopwatches.watches & STOPWATCH3)
 49e:	80 91 a4 00 	lds	r24, 0x00A4
 4a2:	82 ff       	sbrs	r24, 2
 4a4:	09 c0       	rjmp	.+18     	; 0x4b8 <__vector_10+0x8a>
			stopwatches.watch3++;
 4a6:	80 91 a9 00 	lds	r24, 0x00A9
 4aa:	90 91 aa 00 	lds	r25, 0x00AA
 4ae:	01 96       	adiw	r24, 0x01	; 1
 4b0:	90 93 aa 00 	sts	0x00AA, r25
 4b4:	80 93 a9 00 	sts	0x00A9, r24
		if(stopwatches.watches & STOPWATCH4)
 4b8:	80 91 a4 00 	lds	r24, 0x00A4
 4bc:	83 ff       	sbrs	r24, 3
 4be:	09 c0       	rjmp	.+18     	; 0x4d2 <__vector_10+0xa4>
			stopwatches.watch4++;
 4c0:	80 91 ab 00 	lds	r24, 0x00AB
 4c4:	90 91 ac 00 	lds	r25, 0x00AC
 4c8:	01 96       	adiw	r24, 0x01	; 1
 4ca:	90 93 ac 00 	sts	0x00AC, r25
 4ce:	80 93 ab 00 	sts	0x00AB, r24
		if(stopwatches.watches & STOPWATCH5)
 4d2:	80 91 a4 00 	lds	r24, 0x00A4
 4d6:	84 ff       	sbrs	r24, 4
 4d8:	09 c0       	rjmp	.+18     	; 0x4ec <__vector_10+0xbe>
			stopwatches.watch5++;
 4da:	80 91 ad 00 	lds	r24, 0x00AD
 4de:	90 91 ae 00 	lds	r25, 0x00AE
 4e2:	01 96       	adiw	r24, 0x01	; 1
 4e4:	90 93 ae 00 	sts	0x00AE, r25
 4e8:	80 93 ad 00 	sts	0x00AD, r24
		if(stopwatches.watches & STOPWATCH6)
 4ec:	80 91 a4 00 	lds	r24, 0x00A4
 4f0:	85 ff       	sbrs	r24, 5
 4f2:	09 c0       	rjmp	.+18     	; 0x506 <__vector_10+0xd8>
			stopwatches.watch6++;
 4f4:	80 91 af 00 	lds	r24, 0x00AF
 4f8:	90 91 b0 00 	lds	r25, 0x00B0
 4fc:	01 96       	adiw	r24, 0x01	; 1
 4fe:	90 93 b0 00 	sts	0x00B0, r25
 502:	80 93 af 00 	sts	0x00AF, r24
		if(stopwatches.watches & STOPWATCH7)
 506:	80 91 a4 00 	lds	r24, 0x00A4
 50a:	86 ff       	sbrs	r24, 6
 50c:	09 c0       	rjmp	.+18     	; 0x520 <__vector_10+0xf2>
			stopwatches.watch7++;
 50e:	80 91 b1 00 	lds	r24, 0x00B1
 512:	90 91 b2 00 	lds	r25, 0x00B2
 516:	01 96       	adiw	r24, 0x01	; 1
 518:	90 93 b2 00 	sts	0x00B2, r25
 51c:	80 93 b1 00 	sts	0x00B1, r24
		if(stopwatches.watches & STOPWATCH8)
 520:	80 91 a4 00 	lds	r24, 0x00A4
 524:	87 ff       	sbrs	r24, 7
 526:	09 c0       	rjmp	.+18     	; 0x53a <__vector_10+0x10c>
			stopwatches.watch8++;
 528:	80 91 b3 00 	lds	r24, 0x00B3
 52c:	90 91 b4 00 	lds	r25, 0x00B4
 530:	01 96       	adiw	r24, 0x01	; 1
 532:	90 93 b4 00 	sts	0x00B4, r25
 536:	80 93 b3 00 	sts	0x00B3, r24

		// Sound generation timing:
		if(controlStatus.beep) {
 53a:	80 91 92 00 	lds	r24, 0x0092
 53e:	80 ff       	sbrs	r24, 0
 540:	16 c0       	rjmp	.+44     	; 0x56e <__vector_10+0x140>
			if(sound_timer < 1) { // sound_timer * 1ms
 542:	80 91 b8 00 	lds	r24, 0x00B8
 546:	90 91 b9 00 	lds	r25, 0x00B9
 54a:	89 2b       	or	r24, r25
 54c:	39 f4       	brne	.+14     	; 0x55c <__vector_10+0x12e>
				TCCR2 = 0;
 54e:	15 bc       	out	0x25, r1	; 37
				controlStatus.beep = false;
 550:	80 91 92 00 	lds	r24, 0x0092
 554:	8e 7f       	andi	r24, 0xFE	; 254
 556:	80 93 92 00 	sts	0x0092, r24
 55a:	09 c0       	rjmp	.+18     	; 0x56e <__vector_10+0x140>
			}
			else
				sound_timer--;
 55c:	80 91 b8 00 	lds	r24, 0x00B8
 560:	90 91 b9 00 	lds	r25, 0x00B9
 564:	01 97       	sbiw	r24, 0x01	; 1
 566:	90 93 b9 00 	sts	0x00B9, r25
 56a:	80 93 b8 00 	sts	0x00B8, r24
		}
		
		ms_timer = 0;
 56e:	10 92 b7 00 	sts	0x00B7, r1
	}
}
 572:	9f 91       	pop	r25
 574:	8f 91       	pop	r24
 576:	0f 90       	pop	r0
 578:	0f be       	out	0x3f, r0	; 63
 57a:	0f 90       	pop	r0
 57c:	1f 90       	pop	r1
 57e:	18 95       	reti

00000580 <beep>:
 * sounds when you need to do other things at the same
 * time... 
 */
void beep(uint8_t pitch, uint16_t time)
{
	controlStatus.beep = true;
 580:	90 91 92 00 	lds	r25, 0x0092
 584:	91 60       	ori	r25, 0x01	; 1
 586:	90 93 92 00 	sts	0x0092, r25
	sound_timer = time;
 58a:	70 93 b9 00 	sts	0x00B9, r23
 58e:	60 93 b8 00 	sts	0x00B8, r22
	OCR2 = 255-pitch;
 592:	80 95       	com	r24
 594:	83 bd       	out	0x23, r24	; 35
	TCCR2 =  (1 << WGM21) | (1 << COM20) | (1 << CS22) | (1 << CS21);
 596:	8e e1       	ldi	r24, 0x1E	; 30
 598:	85 bd       	out	0x25, r24	; 37
 59a:	08 95       	ret

0000059c <setBeeperPitch>:
 * would sound bad if the beeper turns of for a very short time
 * in between - such as alarm tones or special melodies etc. 
 */
void setBeeperPitch(uint8_t pitch)
{
	controlStatus.beep = false;
 59c:	90 91 92 00 	lds	r25, 0x0092
 5a0:	9e 7f       	andi	r25, 0xFE	; 254
 5a2:	90 93 92 00 	sts	0x0092, r25
	OCR2 = 255-pitch;
 5a6:	98 2f       	mov	r25, r24
 5a8:	90 95       	com	r25
 5aa:	93 bd       	out	0x23, r25	; 35
	if(pitch) 
 5ac:	88 23       	and	r24, r24
 5ae:	19 f0       	breq	.+6      	; 0x5b6 <setBeeperPitch+0x1a>
		TCCR2 =  (1 << WGM21) | (1 << COM20) | (1 << CS22) | (1 << CS21);	
 5b0:	8e e1       	ldi	r24, 0x1E	; 30
 5b2:	85 bd       	out	0x25, r24	; 37
 5b4:	08 95       	ret
	else 
		TCCR2 = 0;
 5b6:	15 bc       	out	0x25, r1	; 37
 5b8:	08 95       	ret

000005ba <sleep>:
 *		// The maximum delay is:
 *		sleep(255); // delay 255 * 100us = 25500us = 25.5ms
 */
void sleep(uint8_t time)
{
	delay_timer = 0;
 5ba:	10 92 b6 00 	sts	0x00B6, r1
	while (delay_timer <= time+1);
 5be:	90 e0       	ldi	r25, 0x00	; 0
 5c0:	01 96       	adiw	r24, 0x01	; 1
 5c2:	20 91 b6 00 	lds	r18, 0x00B6
 5c6:	30 e0       	ldi	r19, 0x00	; 0
 5c8:	82 17       	cp	r24, r18
 5ca:	93 07       	cpc	r25, r19
 5cc:	d4 f7       	brge	.-12     	; 0x5c2 <sleep+0x8>
}
 5ce:	08 95       	ret

000005d0 <mSleep>:
 *      mSleep(100); // delay 100 * 1ms = 100ms = 0.1s
 *		mSleep(1000); // delay 1000 * 1ms = 1000ms = 1s
 *
 */
void mSleep(uint16_t time)
{
 5d0:	cf 93       	push	r28
 5d2:	df 93       	push	r29
 5d4:	ec 01       	movw	r28, r24
	while (time--) sleep(10);
 5d6:	20 97       	sbiw	r28, 0x00	; 0
 5d8:	29 f0       	breq	.+10     	; 0x5e4 <mSleep+0x14>
 5da:	8a e0       	ldi	r24, 0x0A	; 10
 5dc:	0e 94 dd 02 	call	0x5ba	; 0x5ba <sleep>
 5e0:	21 97       	sbiw	r28, 0x01	; 1
 5e2:	f9 cf       	rjmp	.-14     	; 0x5d6 <mSleep+0x6>
}
 5e4:	df 91       	pop	r29
 5e6:	cf 91       	pop	r28
 5e8:	08 95       	ret

000005ea <dischargePeakDetector>:
 * used for the Microphone. This is required to remove any previous
 * charge from the capacitor. 
 */
void dischargePeakDetector(void)
{
	DDRA |= MIC;
 5ea:	d0 9a       	sbi	0x1a, 0	; 26
	PORTA &= ~MIC;
 5ec:	d8 98       	cbi	0x1b, 0	; 27
	mSleep(1);
 5ee:	81 e0       	ldi	r24, 0x01	; 1
 5f0:	90 e0       	ldi	r25, 0x00	; 0
 5f2:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <mSleep>
	DDRA &= ~MIC;
 5f6:	d0 98       	cbi	0x1a, 0	; 26
 5f8:	08 95       	ret

000005fa <getMicrophonePeak>:
/**
 * Reads the Microphone peak detector and discharges it afterwards.
 * 
 */
uint16_t getMicrophonePeak(void)
{
 5fa:	cf 93       	push	r28
 5fc:	df 93       	push	r29
 5fe:	00 d0       	rcall	.+0      	; 0x600 <getMicrophonePeak+0x6>
 600:	cd b7       	in	r28, 0x3d	; 61
 602:	de b7       	in	r29, 0x3e	; 62
	uint16_t tmp;
	tmp = readADC(ADC_MIC);
 604:	80 e0       	ldi	r24, 0x00	; 0
 606:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <readADC>
	if(tmp > 4) 
 60a:	85 30       	cpi	r24, 0x05	; 5
 60c:	91 05       	cpc	r25, r1
 60e:	30 f0       	brcs	.+12     	; 0x61c <getMicrophonePeak+0x22>
		dischargePeakDetector();
 610:	89 83       	std	Y+1, r24	; 0x01
 612:	9a 83       	std	Y+2, r25	; 0x02
 614:	0e 94 f5 02 	call	0x5ea	; 0x5ea <dischargePeakDetector>
 618:	9a 81       	ldd	r25, Y+2	; 0x02
 61a:	89 81       	ldd	r24, Y+1	; 0x01
	return tmp;
}
 61c:	0f 90       	pop	r0
 61e:	0f 90       	pop	r0
 620:	df 91       	pop	r29
 622:	cf 91       	pop	r28
 624:	08 95       	ret

00000626 <delayCycles>:
 * Example:
 * 	delayCycles(1000); // Delays for *about* 1000 instruction cycles
 */
void delayCycles(uint16_t dly)
{
	while(dly--) nop();
 626:	01 97       	sbiw	r24, 0x01	; 1
 628:	10 f0       	brcs	.+4      	; 0x62e <delayCycles+0x8>
 62a:	00 00       	nop
 62c:	fc cf       	rjmp	.-8      	; 0x626 <delayCycles>
}
 62e:	08 95       	ret

00000630 <setLCDD>:
 * enable line of the LCD to 'inform' the LCD about the new data.
 *
 */
void setLCDD(uint8_t lcdd)
{
	externalPort.LCDD = lcdd;
 630:	82 95       	swap	r24
 632:	80 7f       	andi	r24, 0xF0	; 240
 634:	90 91 b5 00 	lds	r25, 0x00B5
 638:	9f 70       	andi	r25, 0x0F	; 15
 63a:	98 2b       	or	r25, r24
 63c:	90 93 b5 00 	sts	0x00B5, r25
	outputExt();
 640:	0e 94 ab 01 	call	0x356	; 0x356 <outputExt>
	PORTB |= LCD_EN;
 644:	c4 9a       	sbi	0x18, 4	; 24
	delayCycles(50);
 646:	82 e3       	ldi	r24, 0x32	; 50
 648:	90 e0       	ldi	r25, 0x00	; 0
 64a:	0e 94 13 03 	call	0x626	; 0x626 <delayCycles>
	PORTB &= ~LCD_EN;
 64e:	c4 98       	cbi	0x18, 4	; 24
 650:	08 95       	ret

00000652 <write4BitLCDData>:

/**
 * Write a 8bit-byte in two nibbles of 4bit to the LCD.
 */
void write4BitLCDData(uint8_t data)
{
 652:	cf 93       	push	r28
 654:	c8 2f       	mov	r28, r24
	setLCDD(data >> 4);
 656:	82 95       	swap	r24
 658:	8f 70       	andi	r24, 0x0F	; 15
 65a:	0e 94 18 03 	call	0x630	; 0x630 <setLCDD>
	setLCDD(data);
 65e:	8c 2f       	mov	r24, r28
 660:	0e 94 18 03 	call	0x630	; 0x630 <setLCDD>
	delayCycles(150);
 664:	86 e9       	ldi	r24, 0x96	; 150
 666:	90 e0       	ldi	r25, 0x00	; 0
}
 668:	cf 91       	pop	r28
 */
void write4BitLCDData(uint8_t data)
{
	setLCDD(data >> 4);
	setLCDD(data);
	delayCycles(150);
 66a:	0c 94 13 03 	jmp	0x626	; 0x626 <delayCycles>

0000066e <writeLCDCommand>:
/**
 * Write a command to the LCD.
 */
void writeLCDCommand(uint8_t cmd)
{
	PORTB &= ~LCD_RS;
 66e:	c3 98       	cbi	0x18, 3	; 24
	write4BitLCDData(cmd);
 670:	0e 94 29 03 	call	0x652	; 0x652 <write4BitLCDData>
	delayCycles(150);
 674:	86 e9       	ldi	r24, 0x96	; 150
 676:	90 e0       	ldi	r25, 0x00	; 0
 678:	0c 94 13 03 	jmp	0x626	; 0x626 <delayCycles>

0000067c <setCursorPosLCD>:
/**
 * Sets the cursor position on LCD.
 */
void setCursorPosLCD(uint8_t line, uint8_t pos)
{
	pos |= 128;
 67c:	60 68       	ori	r22, 0x80	; 128
	if(line==1) pos += 0x40;
 67e:	81 30       	cpi	r24, 0x01	; 1
 680:	09 f4       	brne	.+2      	; 0x684 <setCursorPosLCD+0x8>
 682:	60 5c       	subi	r22, 0xC0	; 192
	writeLCDCommand(pos);
 684:	86 2f       	mov	r24, r22
 686:	0c 94 37 03 	jmp	0x66e	; 0x66e <writeLCDCommand>

0000068a <initLCD>:
 */
void initLCD(void)
{
	//delayCycles(34000); No need for Power ON delay as usually the
	// Bootloader should have been executed before...
	setLCDD(0b0011);
 68a:	83 e0       	ldi	r24, 0x03	; 3
 68c:	0e 94 18 03 	call	0x630	; 0x630 <setLCDD>
	delayCycles(18000);
 690:	80 e5       	ldi	r24, 0x50	; 80
 692:	96 e4       	ldi	r25, 0x46	; 70
 694:	0e 94 13 03 	call	0x626	; 0x626 <delayCycles>
	setLCDD(0b0011);
 698:	83 e0       	ldi	r24, 0x03	; 3
 69a:	0e 94 18 03 	call	0x630	; 0x630 <setLCDD>
	delayCycles(5500);
 69e:	8c e7       	ldi	r24, 0x7C	; 124
 6a0:	95 e1       	ldi	r25, 0x15	; 21
 6a2:	0e 94 13 03 	call	0x626	; 0x626 <delayCycles>
	setLCDD(0b0011);
 6a6:	83 e0       	ldi	r24, 0x03	; 3
 6a8:	0e 94 18 03 	call	0x630	; 0x630 <setLCDD>
	delayCycles(5500);
 6ac:	8c e7       	ldi	r24, 0x7C	; 124
 6ae:	95 e1       	ldi	r25, 0x15	; 21
 6b0:	0e 94 13 03 	call	0x626	; 0x626 <delayCycles>
	setLCDD(0b0010);
 6b4:	82 e0       	ldi	r24, 0x02	; 2
 6b6:	0e 94 18 03 	call	0x630	; 0x630 <setLCDD>
	delayCycles(5500);
 6ba:	8c e7       	ldi	r24, 0x7C	; 124
 6bc:	95 e1       	ldi	r25, 0x15	; 21
 6be:	0e 94 13 03 	call	0x626	; 0x626 <delayCycles>
	writeLCDCommand(0b00101000);
 6c2:	88 e2       	ldi	r24, 0x28	; 40
 6c4:	0e 94 37 03 	call	0x66e	; 0x66e <writeLCDCommand>
	delayCycles(5500);
 6c8:	8c e7       	ldi	r24, 0x7C	; 124
 6ca:	95 e1       	ldi	r25, 0x15	; 21
 6cc:	0e 94 13 03 	call	0x626	; 0x626 <delayCycles>
	writeLCDCommand(0b00001000);
 6d0:	88 e0       	ldi	r24, 0x08	; 8
 6d2:	0e 94 37 03 	call	0x66e	; 0x66e <writeLCDCommand>
	delayCycles(5500);
 6d6:	8c e7       	ldi	r24, 0x7C	; 124
 6d8:	95 e1       	ldi	r25, 0x15	; 21
 6da:	0e 94 13 03 	call	0x626	; 0x626 <delayCycles>
	writeLCDCommand(0b00000001);
 6de:	81 e0       	ldi	r24, 0x01	; 1
 6e0:	0e 94 37 03 	call	0x66e	; 0x66e <writeLCDCommand>
	delayCycles(5500);
 6e4:	8c e7       	ldi	r24, 0x7C	; 124
 6e6:	95 e1       	ldi	r25, 0x15	; 21
 6e8:	0e 94 13 03 	call	0x626	; 0x626 <delayCycles>
	writeLCDCommand(0b00000010);
 6ec:	82 e0       	ldi	r24, 0x02	; 2
 6ee:	0e 94 37 03 	call	0x66e	; 0x66e <writeLCDCommand>
	delayCycles(5500);
 6f2:	8c e7       	ldi	r24, 0x7C	; 124
 6f4:	95 e1       	ldi	r25, 0x15	; 21
 6f6:	0e 94 13 03 	call	0x626	; 0x626 <delayCycles>
	writeLCDCommand(0b00001100);
 6fa:	8c e0       	ldi	r24, 0x0C	; 12
 6fc:	0e 94 37 03 	call	0x66e	; 0x66e <writeLCDCommand>
	delayCycles(5500);
 700:	8c e7       	ldi	r24, 0x7C	; 124
 702:	95 e1       	ldi	r25, 0x15	; 21
 704:	0c 94 13 03 	jmp	0x626	; 0x626 <delayCycles>

00000708 <clearLCD>:
/**
 * Clears the whole LCD!
 */
void clearLCD(void)
{
	writeLCDCommand(0b00000001);
 708:	81 e0       	ldi	r24, 0x01	; 1
 70a:	0e 94 37 03 	call	0x66e	; 0x66e <writeLCDCommand>
	delayCycles(5500);
 70e:	8c e7       	ldi	r24, 0x7C	; 124
 710:	95 e1       	ldi	r25, 0x15	; 21
 712:	0c 94 13 03 	jmp	0x626	; 0x626 <delayCycles>

00000716 <writeCharLCD>:
 *			use setCursorPos function to move the cursor to a 
 *			different location!
 */
void writeCharLCD(uint8_t ch)
{
	PORTB |= LCD_RS;
 716:	c3 9a       	sbi	0x18, 3	; 24
	write4BitLCDData(ch);
 718:	0e 94 29 03 	call	0x652	; 0x652 <write4BitLCDData>
	delayCycles(50);
 71c:	82 e3       	ldi	r24, 0x32	; 50
 71e:	90 e0       	ldi	r25, 0x00	; 0
 720:	0c 94 13 03 	jmp	0x626	; 0x626 <delayCycles>

00000724 <writeNStringLCD_P>:
 *			// you can simply write:
 *			writeStringLCD_P("RP6 Control");
 *
 */
void writeNStringLCD_P(const char *pstring)
{
 724:	cf 93       	push	r28
 726:	df 93       	push	r29
 728:	fc 01       	movw	r30, r24
    uint8_t c;
    for (;(c = pgm_read_byte_near(pstring++));writeCharLCD(c));
 72a:	84 91       	lpm	r24, Z
 72c:	ef 01       	movw	r28, r30
 72e:	21 96       	adiw	r28, 0x01	; 1
 730:	88 23       	and	r24, r24
 732:	21 f0       	breq	.+8      	; 0x73c <writeNStringLCD_P+0x18>
 734:	0e 94 8b 03 	call	0x716	; 0x716 <writeCharLCD>
 738:	fe 01       	movw	r30, r28
 73a:	f7 cf       	rjmp	.-18     	; 0x72a <writeNStringLCD_P+0x6>
}
 73c:	df 91       	pop	r29
 73e:	cf 91       	pop	r28
 740:	08 95       	ret

00000742 <_showScreenLCD_P>:
 * This function is useful for displaying text screens on the LCD.
 * It clears the whole LCD and writes the two Strings to line 1 and
 * line 2.
 */
void _showScreenLCD_P(const char *line1, const char *line2)
{
 742:	0f 93       	push	r16
 744:	1f 93       	push	r17
 746:	cf 93       	push	r28
 748:	df 93       	push	r29
 74a:	00 d0       	rcall	.+0      	; 0x74c <_showScreenLCD_P+0xa>
 74c:	cd b7       	in	r28, 0x3d	; 61
 74e:	de b7       	in	r29, 0x3e	; 62
 750:	8b 01       	movw	r16, r22
	clearLCD();
 752:	89 83       	std	Y+1, r24	; 0x01
 754:	9a 83       	std	Y+2, r25	; 0x02
 756:	0e 94 84 03 	call	0x708	; 0x708 <clearLCD>
	writeNStringLCD_P(line1);
 75a:	89 81       	ldd	r24, Y+1	; 0x01
 75c:	9a 81       	ldd	r25, Y+2	; 0x02
 75e:	0e 94 92 03 	call	0x724	; 0x724 <writeNStringLCD_P>
 */
void setCursorPosLCD(uint8_t line, uint8_t pos)
{
	pos |= 128;
	if(line==1) pos += 0x40;
	writeLCDCommand(pos);
 762:	80 ec       	ldi	r24, 0xC0	; 192
 764:	0e 94 37 03 	call	0x66e	; 0x66e <writeLCDCommand>
void _showScreenLCD_P(const char *line1, const char *line2)
{
	clearLCD();
	writeNStringLCD_P(line1);
	setCursorPosLCD(1, 0);
	writeNStringLCD_P(line2);
 768:	c8 01       	movw	r24, r16
}
 76a:	0f 90       	pop	r0
 76c:	0f 90       	pop	r0
 76e:	df 91       	pop	r29
 770:	cf 91       	pop	r28
 772:	1f 91       	pop	r17
 774:	0f 91       	pop	r16
void _showScreenLCD_P(const char *line1, const char *line2)
{
	clearLCD();
	writeNStringLCD_P(line1);
	setCursorPosLCD(1, 0);
	writeNStringLCD_P(line2);
 776:	0c 94 92 03 	jmp	0x724	; 0x724 <writeNStringLCD_P>

0000077a <writeStringLCD>:

/**
 * Writes a String from SRAM to the LCD.
 */
void writeStringLCD(char *string)
{
 77a:	cf 93       	push	r28
 77c:	df 93       	push	r29
 77e:	ec 01       	movw	r28, r24
	while(*string)
 780:	89 91       	ld	r24, Y+
 782:	88 23       	and	r24, r24
 784:	19 f0       	breq	.+6      	; 0x78c <writeStringLCD+0x12>
		writeCharLCD(*string++);
 786:	0e 94 8b 03 	call	0x716	; 0x716 <writeCharLCD>
 78a:	fa cf       	rjmp	.-12     	; 0x780 <writeStringLCD+0x6>
}
 78c:	df 91       	pop	r29
 78e:	cf 91       	pop	r28
 790:	08 95       	ret

00000792 <writeIntegerLCD>:
 *			writeInteger(511,OCT);		// Ocal
 *			writeInteger(0b11010111,BIN); // Binary
 */
void writeIntegerLCD(int16_t number, uint8_t base)
{
	itoa(number, &lcd_tmp_buffer[0], base);
 792:	46 2f       	mov	r20, r22
 794:	50 e0       	ldi	r21, 0x00	; 0
 796:	63 e9       	ldi	r22, 0x93	; 147
 798:	70 e0       	ldi	r23, 0x00	; 0
 79a:	0e 94 45 06 	call	0xc8a	; 0xc8a <itoa>
	writeStringLCD(&lcd_tmp_buffer[0]);
 79e:	83 e9       	ldi	r24, 0x93	; 147
 7a0:	90 e0       	ldi	r25, 0x00	; 0
 7a2:	0c 94 bd 03 	jmp	0x77a	; 0x77a <writeStringLCD>

000007a6 <writeStringLengthLCD>:
 *			// would output: "Robot System"
 *			// No matter if the specified length is 40 characters!
 *
 */
void writeStringLengthLCD(char *string, uint8_t length, uint8_t offset)
{
 7a6:	0f 93       	push	r16
 7a8:	1f 93       	push	r17
 7aa:	cf 93       	push	r28
 7ac:	df 93       	push	r29
 7ae:	1f 92       	push	r1
 7b0:	cd b7       	in	r28, 0x3d	; 61
 7b2:	de b7       	in	r29, 0x3e	; 62
	for(string = &string[offset]; *string && length; length--)
 7b4:	8c 01       	movw	r16, r24
 7b6:	04 0f       	add	r16, r20
 7b8:	11 1d       	adc	r17, r1
 7ba:	f8 01       	movw	r30, r16
 7bc:	81 91       	ld	r24, Z+
 7be:	8f 01       	movw	r16, r30
 7c0:	88 23       	and	r24, r24
 7c2:	41 f0       	breq	.+16     	; 0x7d4 <writeStringLengthLCD+0x2e>
 7c4:	66 23       	and	r22, r22
 7c6:	31 f0       	breq	.+12     	; 0x7d4 <writeStringLengthLCD+0x2e>
		writeCharLCD(*string++);
 7c8:	69 83       	std	Y+1, r22	; 0x01
 7ca:	0e 94 8b 03 	call	0x716	; 0x716 <writeCharLCD>
 *			// No matter if the specified length is 40 characters!
 *
 */
void writeStringLengthLCD(char *string, uint8_t length, uint8_t offset)
{
	for(string = &string[offset]; *string && length; length--)
 7ce:	69 81       	ldd	r22, Y+1	; 0x01
 7d0:	61 50       	subi	r22, 0x01	; 1
 7d2:	f3 cf       	rjmp	.-26     	; 0x7ba <writeStringLengthLCD+0x14>
		writeCharLCD(*string++);
}
 7d4:	0f 90       	pop	r0
 7d6:	df 91       	pop	r29
 7d8:	cf 91       	pop	r28
 7da:	1f 91       	pop	r17
 7dc:	0f 91       	pop	r16
 7de:	08 95       	ret

000007e0 <writeIntegerLengthLCD>:
 *			writeIntegerLength(511,OCT,4);		// Ocal
 *			writeIntegerLength(0b11010111,BIN,8); // Binary
 */
 
void writeIntegerLengthLCD(int16_t number, uint8_t base, uint8_t length)
{
 7e0:	ef 92       	push	r14
 7e2:	ff 92       	push	r15
 7e4:	0f 93       	push	r16
 7e6:	1f 93       	push	r17
 7e8:	cf 93       	push	r28
 7ea:	df 93       	push	r29
 7ec:	cd b7       	in	r28, 0x3d	; 61
 7ee:	de b7       	in	r29, 0x3e	; 62
 7f0:	61 97       	sbiw	r28, 0x11	; 17
 7f2:	0f b6       	in	r0, 0x3f	; 63
 7f4:	f8 94       	cli
 7f6:	de bf       	out	0x3e, r29	; 62
 7f8:	0f be       	out	0x3f, r0	; 63
 7fa:	cd bf       	out	0x3d, r28	; 61
 7fc:	e4 2e       	mov	r14, r20
	char buffer[17];
	itoa(number, &buffer[0], base);
 7fe:	46 2f       	mov	r20, r22
 800:	50 e0       	ldi	r21, 0x00	; 0
 802:	8e 01       	movw	r16, r28
 804:	0f 5f       	subi	r16, 0xFF	; 255
 806:	1f 4f       	sbci	r17, 0xFF	; 255
 808:	b8 01       	movw	r22, r16
 80a:	0e 94 45 06 	call	0xc8a	; 0xc8a <itoa>
	int8_t cnt = length - strlen(buffer);
 80e:	f8 01       	movw	r30, r16
 810:	01 90       	ld	r0, Z+
 812:	00 20       	and	r0, r0
 814:	e9 f7       	brne	.-6      	; 0x810 <writeIntegerLengthLCD+0x30>
 816:	31 97       	sbiw	r30, 0x01	; 1
 818:	e0 1b       	sub	r30, r16
 81a:	f1 0b       	sbc	r31, r17
 81c:	fe 2c       	mov	r15, r14
 81e:	fe 1a       	sub	r15, r30
	if(cnt > 0) {
 820:	1f 14       	cp	r1, r15
 822:	54 f4       	brge	.+20     	; 0x838 <writeIntegerLengthLCD+0x58>
 824:	fa 94       	dec	r15
		for(; cnt > 0; cnt--, writeCharLCD('0'));
 826:	80 e3       	ldi	r24, 0x30	; 48
 828:	0e 94 8b 03 	call	0x716	; 0x716 <writeCharLCD>
 82c:	f1 10       	cpse	r15, r1
 82e:	fa cf       	rjmp	.-12     	; 0x824 <writeIntegerLengthLCD+0x44>
		writeStringLCD(&buffer[0]);
 830:	c8 01       	movw	r24, r16
 832:	0e 94 bd 03 	call	0x77a	; 0x77a <writeStringLCD>
 836:	06 c0       	rjmp	.+12     	; 0x844 <writeIntegerLengthLCD+0x64>
	}
	else 
		writeStringLengthLCD(&buffer[0],length,-cnt);
 838:	4f 2d       	mov	r20, r15
 83a:	41 95       	neg	r20
 83c:	6e 2d       	mov	r22, r14
 83e:	c8 01       	movw	r24, r16
 840:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <writeStringLengthLCD>
}
 844:	61 96       	adiw	r28, 0x11	; 17
 846:	0f b6       	in	r0, 0x3f	; 63
 848:	f8 94       	cli
 84a:	de bf       	out	0x3e, r29	; 62
 84c:	0f be       	out	0x3f, r0	; 63
 84e:	cd bf       	out	0x3d, r28	; 61
 850:	df 91       	pop	r29
 852:	cf 91       	pop	r28
 854:	1f 91       	pop	r17
 856:	0f 91       	pop	r16
 858:	ff 90       	pop	r15
 85a:	ef 90       	pop	r14
 85c:	08 95       	ret

0000085e <clearPosLCD>:

/**
 * Clears some characters after the given position.
 */
void clearPosLCD(uint8_t line, uint8_t pos, uint8_t length)
{
 85e:	cf 93       	push	r28
 860:	c4 2f       	mov	r28, r20
	setCursorPosLCD(line,pos);
 862:	0e 94 3e 03 	call	0x67c	; 0x67c <setCursorPosLCD>
	while(length--)
 866:	cc 23       	and	r28, r28
 868:	29 f0       	breq	.+10     	; 0x874 <__stack+0x15>
		writeCharLCD(' ');
 86a:	80 e2       	ldi	r24, 0x20	; 32
 86c:	0e 94 8b 03 	call	0x716	; 0x716 <writeCharLCD>
 870:	c1 50       	subi	r28, 0x01	; 1
 872:	f9 cf       	rjmp	.-14     	; 0x866 <__stack+0x7>
}
 874:	cf 91       	pop	r28
 876:	08 95       	ret

00000878 <initRP6Control>:
 *			}
 *
 */
void initRP6Control(void)
{
	portInit();		// Setup port directions and initial values.
 878:	1b ba       	out	0x1b, r1	; 27
 87a:	87 e0       	ldi	r24, 0x07	; 7
 87c:	88 bb       	out	0x18, r24	; 24
 87e:	8c ef       	ldi	r24, 0xFC	; 252
 880:	85 bb       	out	0x15, r24	; 21
 882:	81 e6       	ldi	r24, 0x61	; 97
 884:	82 bb       	out	0x12, r24	; 18
 886:	1a ba       	out	0x1a, r1	; 26
 888:	8b eb       	ldi	r24, 0xBB	; 187
 88a:	87 bb       	out	0x17, r24	; 23
 88c:	14 ba       	out	0x14, r1	; 20
 88e:	82 e9       	ldi	r24, 0x92	; 146
 890:	81 bb       	out	0x11, r24	; 17
					// This is the most important step!

	cli();			// Disable global interrupts.
 892:	f8 94       	cli

	// UART:
	UBRRH = UBRR_BAUD_LOW >> 8;	// Setup UART: Baud is Low Speed
 894:	10 bc       	out	0x20, r1	; 32
	UBRRL = (uint8_t) UBRR_BAUD_LOW;
 896:	89 e1       	ldi	r24, 0x19	; 25
 898:	89 b9       	out	0x09, r24	; 9
	UCSRA = 0x00;
 89a:	1b b8       	out	0x0b, r1	; 11
    UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
 89c:	86 e8       	ldi	r24, 0x86	; 134
 89e:	80 bd       	out	0x20, r24	; 32
    UCSRB = (1 << TXEN) | (1 << RXEN) | (1 << RXCIE);
 8a0:	88 e9       	ldi	r24, 0x98	; 152
 8a2:	8a b9       	out	0x0a, r24	; 10
	
	// Initialize ADC:
	ADMUX = 0; //external reference 
 8a4:	17 b8       	out	0x07, r1	; 7
	ADCSRA = (0<<ADIE) | (0<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADIF);
 8a6:	86 e1       	ldi	r24, 0x16	; 22
 8a8:	86 b9       	out	0x06, r24	; 6
	SFIOR = 0;
 8aa:	10 be       	out	0x30, r1	; 48

	// Initialize External interrupts - all disabled:
	MCUCR = (1 << ISC11) | (1 << ISC10) | (1 << ISC01) | (1 << ISC00);
 8ac:	8f e0       	ldi	r24, 0x0F	; 15
 8ae:	85 bf       	out	0x35, r24	; 53
	GICR = (0 << INT2) | (0 << INT1) | (0 << INT0);
 8b0:	1b be       	out	0x3b, r1	; 59
	MCUCSR = (0 << ISC2);
 8b2:	14 be       	out	0x34, r1	; 52
	
	
	// 10kHz Timer 0:
	TCCR0 =   (0 << WGM00) 
 8b4:	8a e0       	ldi	r24, 0x0A	; 10
 8b6:	83 bf       	out	0x33, r24	; 51
			| (0 << COM00) 
			| (0 << COM01) 
			| (0 << CS02)  
			| (1 << CS01) 
			| (0 << CS00);
	OCR0  = 199;
 8b8:	87 ec       	ldi	r24, 0xC7	; 199
 8ba:	8c bf       	out	0x3c, r24	; 60
/*
	Timer 1 is free for your application!
*/

	// Timer 2 - used for beeper:
	TCCR2 =  0; 
 8bc:	15 bc       	out	0x25, r1	; 37
	OCR2  = 0xFF; 
 8be:	8f ef       	ldi	r24, 0xFF	; 255
 8c0:	83 bd       	out	0x23, r24	; 35

	// Enable timer interrupts:
	TIMSK =   (1 << OCIE0); 
 8c2:	82 e0       	ldi	r24, 0x02	; 2
 8c4:	89 bf       	out	0x39, r24	; 57

	// SPI Master (SPI Mode 0, SCK Frequency is F_CPU/2, which means it is 8MHz 
	// on the RP6 CONTROL M32...):
	SPCR =    (0<<SPIE) 
 8c6:	80 e5       	ldi	r24, 0x50	; 80
 8c8:	8d b9       	out	0x0d, r24	; 13
			| (1<<MSTR) 
			| (0<<SPR0) 
			| (0<<SPR1) 
			| (0<<CPOL) 
			| (0<<CPHA);  
	SPSR = (1<<SPI2X);
 8ca:	81 e0       	ldi	r24, 0x01	; 1
 8cc:	8e b9       	out	0x0e, r24	; 14
	
	sei(); // Enable Global Interrupts
 8ce:	78 94       	sei
 8d0:	08 95       	ret

000008d2 <writeChar>:
 *			00123
 *
 */
void writeChar(char ch)
{
    while (!(UCSRA & (1<<UDRE)));
 8d2:	5d 9b       	sbis	0x0b, 5	; 11
 8d4:	fe cf       	rjmp	.-4      	; 0x8d2 <writeChar>
    UDR = (uint8_t)ch;
 8d6:	8c b9       	out	0x0c, r24	; 12
 8d8:	08 95       	ret

000008da <writeString>:
 *
 *			writeString("RP6 Robot System\n");
 *
 */
void writeString(char *string)
{
 8da:	cf 93       	push	r28
 8dc:	df 93       	push	r29
 8de:	ec 01       	movw	r28, r24
	while(*string)
 8e0:	89 91       	ld	r24, Y+
 8e2:	88 23       	and	r24, r24
 8e4:	19 f0       	breq	.+6      	; 0x8ec <writeString+0x12>
		writeChar(*string++);
 8e6:	0e 94 69 04 	call	0x8d2	; 0x8d2 <writeChar>
 8ea:	fa cf       	rjmp	.-12     	; 0x8e0 <writeString+0x6>
}
 8ec:	df 91       	pop	r29
 8ee:	cf 91       	pop	r28
 8f0:	08 95       	ret

000008f2 <writeNStringP>:
 *			// you can simply write:
 *			writeString_P("RP6 Robot System\n");
 *
 */
void writeNStringP(const char *pstring)
{
 8f2:	cf 93       	push	r28
 8f4:	df 93       	push	r29
 8f6:	fc 01       	movw	r30, r24
    uint8_t c;
    for (;(c = pgm_read_byte_near(pstring++));writeChar(c));
 8f8:	84 91       	lpm	r24, Z
 8fa:	ef 01       	movw	r28, r30
 8fc:	21 96       	adiw	r28, 0x01	; 1
 8fe:	88 23       	and	r24, r24
 900:	21 f0       	breq	.+8      	; 0x90a <writeNStringP+0x18>
 902:	0e 94 69 04 	call	0x8d2	; 0x8d2 <writeChar>
 906:	fe 01       	movw	r30, r28
 908:	f7 cf       	rjmp	.-18     	; 0x8f8 <writeNStringP+0x6>
}
 90a:	df 91       	pop	r29
 90c:	cf 91       	pop	r28
 90e:	08 95       	ret

00000910 <writeStringLength>:
 *			// would output: "Robot System\n"
 *			// No matter if the specified length is 40 characters!
 *
 */
void writeStringLength(char *string, uint8_t length, uint8_t offset)
{
 910:	0f 93       	push	r16
 912:	1f 93       	push	r17
 914:	cf 93       	push	r28
 916:	df 93       	push	r29
 918:	1f 92       	push	r1
 91a:	cd b7       	in	r28, 0x3d	; 61
 91c:	de b7       	in	r29, 0x3e	; 62
	for(string = &string[offset]; *string && length; length--)
 91e:	8c 01       	movw	r16, r24
 920:	04 0f       	add	r16, r20
 922:	11 1d       	adc	r17, r1
 924:	f8 01       	movw	r30, r16
 926:	81 91       	ld	r24, Z+
 928:	8f 01       	movw	r16, r30
 92a:	88 23       	and	r24, r24
 92c:	41 f0       	breq	.+16     	; 0x93e <writeStringLength+0x2e>
 92e:	66 23       	and	r22, r22
 930:	31 f0       	breq	.+12     	; 0x93e <writeStringLength+0x2e>
		writeChar(*string++);
 932:	69 83       	std	Y+1, r22	; 0x01
 934:	0e 94 69 04 	call	0x8d2	; 0x8d2 <writeChar>
 *			// No matter if the specified length is 40 characters!
 *
 */
void writeStringLength(char *string, uint8_t length, uint8_t offset)
{
	for(string = &string[offset]; *string && length; length--)
 938:	69 81       	ldd	r22, Y+1	; 0x01
 93a:	61 50       	subi	r22, 0x01	; 1
 93c:	f3 cf       	rjmp	.-26     	; 0x924 <writeStringLength+0x14>
		writeChar(*string++);
}
 93e:	0f 90       	pop	r0
 940:	df 91       	pop	r29
 942:	cf 91       	pop	r28
 944:	1f 91       	pop	r17
 946:	0f 91       	pop	r16
 948:	08 95       	ret

0000094a <writeInteger>:
 *			writeInteger(1024,DEC);  	// Decimal
 *			writeInteger(044,OCT);		// Ocal
 *			writeInteger(0b11010111,BIN); // Binary
 */
void writeInteger(int16_t number, uint8_t base)
{
 94a:	cf 93       	push	r28
 94c:	df 93       	push	r29
 94e:	cd b7       	in	r28, 0x3d	; 61
 950:	de b7       	in	r29, 0x3e	; 62
 952:	61 97       	sbiw	r28, 0x11	; 17
 954:	0f b6       	in	r0, 0x3f	; 63
 956:	f8 94       	cli
 958:	de bf       	out	0x3e, r29	; 62
 95a:	0f be       	out	0x3f, r0	; 63
 95c:	cd bf       	out	0x3d, r28	; 61
	char buffer[17];
	itoa(number, &buffer[0], base);
 95e:	46 2f       	mov	r20, r22
 960:	50 e0       	ldi	r21, 0x00	; 0
 962:	be 01       	movw	r22, r28
 964:	6f 5f       	subi	r22, 0xFF	; 255
 966:	7f 4f       	sbci	r23, 0xFF	; 255
 968:	0e 94 45 06 	call	0xc8a	; 0xc8a <itoa>
	writeString(&buffer[0]);
 96c:	ce 01       	movw	r24, r28
 96e:	01 96       	adiw	r24, 0x01	; 1
 970:	0e 94 6d 04 	call	0x8da	; 0x8da <writeString>
}
 974:	61 96       	adiw	r28, 0x11	; 17
 976:	0f b6       	in	r0, 0x3f	; 63
 978:	f8 94       	cli
 97a:	de bf       	out	0x3e, r29	; 62
 97c:	0f be       	out	0x3f, r0	; 63
 97e:	cd bf       	out	0x3d, r28	; 61
 980:	df 91       	pop	r29
 982:	cf 91       	pop	r28
 984:	08 95       	ret

00000986 <writeIntegerLength>:
 *			writeIntegerLength(1024,DEC,6);  	// Decimal
 *			writeIntegerLength(044,OCT,4);		// Ocal
 *			writeIntegerLength(0b11010111,BIN,8); // Binary
 */
void writeIntegerLength(int16_t number, uint8_t base, uint8_t length)
{
 986:	ef 92       	push	r14
 988:	ff 92       	push	r15
 98a:	0f 93       	push	r16
 98c:	1f 93       	push	r17
 98e:	cf 93       	push	r28
 990:	df 93       	push	r29
 992:	cd b7       	in	r28, 0x3d	; 61
 994:	de b7       	in	r29, 0x3e	; 62
 996:	61 97       	sbiw	r28, 0x11	; 17
 998:	0f b6       	in	r0, 0x3f	; 63
 99a:	f8 94       	cli
 99c:	de bf       	out	0x3e, r29	; 62
 99e:	0f be       	out	0x3f, r0	; 63
 9a0:	cd bf       	out	0x3d, r28	; 61
 9a2:	e4 2e       	mov	r14, r20
	char buffer[17];
	itoa(number, &buffer[0], base);
 9a4:	46 2f       	mov	r20, r22
 9a6:	50 e0       	ldi	r21, 0x00	; 0
 9a8:	8e 01       	movw	r16, r28
 9aa:	0f 5f       	subi	r16, 0xFF	; 255
 9ac:	1f 4f       	sbci	r17, 0xFF	; 255
 9ae:	b8 01       	movw	r22, r16
 9b0:	0e 94 45 06 	call	0xc8a	; 0xc8a <itoa>
	int8_t cnt = length - strlen(buffer);
 9b4:	f8 01       	movw	r30, r16
 9b6:	01 90       	ld	r0, Z+
 9b8:	00 20       	and	r0, r0
 9ba:	e9 f7       	brne	.-6      	; 0x9b6 <writeIntegerLength+0x30>
 9bc:	31 97       	sbiw	r30, 0x01	; 1
 9be:	e0 1b       	sub	r30, r16
 9c0:	f1 0b       	sbc	r31, r17
 9c2:	fe 2c       	mov	r15, r14
 9c4:	fe 1a       	sub	r15, r30
	if(cnt > 0) {
 9c6:	1f 14       	cp	r1, r15
 9c8:	54 f4       	brge	.+20     	; 0x9de <writeIntegerLength+0x58>
 9ca:	fa 94       	dec	r15
		for(; cnt > 0; cnt--, writeChar('0'));
 9cc:	80 e3       	ldi	r24, 0x30	; 48
 9ce:	0e 94 69 04 	call	0x8d2	; 0x8d2 <writeChar>
 9d2:	f1 10       	cpse	r15, r1
 9d4:	fa cf       	rjmp	.-12     	; 0x9ca <writeIntegerLength+0x44>
		writeString(&buffer[0]);
 9d6:	c8 01       	movw	r24, r16
 9d8:	0e 94 6d 04 	call	0x8da	; 0x8da <writeString>
 9dc:	06 c0       	rjmp	.+12     	; 0x9ea <writeIntegerLength+0x64>
	}
	else 
		writeStringLength(&buffer[0],length,-cnt);
 9de:	4f 2d       	mov	r20, r15
 9e0:	41 95       	neg	r20
 9e2:	6e 2d       	mov	r22, r14
 9e4:	c8 01       	movw	r24, r16
 9e6:	0e 94 88 04 	call	0x910	; 0x910 <writeStringLength>
}
 9ea:	61 96       	adiw	r28, 0x11	; 17
 9ec:	0f b6       	in	r0, 0x3f	; 63
 9ee:	f8 94       	cli
 9f0:	de bf       	out	0x3e, r29	; 62
 9f2:	0f be       	out	0x3f, r0	; 63
 9f4:	cd bf       	out	0x3d, r28	; 61
 9f6:	df 91       	pop	r29
 9f8:	cf 91       	pop	r28
 9fa:	1f 91       	pop	r17
 9fc:	0f 91       	pop	r16
 9fe:	ff 90       	pop	r15
 a00:	ef 90       	pop	r14
 a02:	08 95       	ret

00000a04 <__vector_13>:
/**
 * UART receive ISR.
 * Handles reception to circular buffer.
 */
ISR(USART_RXC_vect)
{	
 a04:	1f 92       	push	r1
 a06:	0f 92       	push	r0
 a08:	0f b6       	in	r0, 0x3f	; 63
 a0a:	0f 92       	push	r0
 a0c:	11 24       	eor	r1, r1
 a0e:	2f 93       	push	r18
 a10:	8f 93       	push	r24
 a12:	9f 93       	push	r25
 a14:	ef 93       	push	r30
 a16:	ff 93       	push	r31
	static volatile uint8_t dummy;
	if(((uint8_t)(write_size - read_size)) < UART_RECEIVE_BUFFER_SIZE) {
 a18:	90 91 84 00 	lds	r25, 0x0084
 a1c:	80 91 85 00 	lds	r24, 0x0085
 a20:	29 2f       	mov	r18, r25
 a22:	28 1b       	sub	r18, r24
 a24:	20 32       	cpi	r18, 0x20	; 32
 a26:	a8 f4       	brcc	.+42     	; 0xa52 <__vector_13+0x4e>
		uart_receive_buffer[write_pos++] = UDR;
 a28:	e0 91 86 00 	lds	r30, 0x0086
 a2c:	81 e0       	ldi	r24, 0x01	; 1
 a2e:	8e 0f       	add	r24, r30
 a30:	80 93 86 00 	sts	0x0086, r24
 a34:	f0 e0       	ldi	r31, 0x00	; 0
 a36:	2c b1       	in	r18, 0x0c	; 12
 a38:	e5 54       	subi	r30, 0x45	; 69
 a3a:	ff 4f       	sbci	r31, 0xFF	; 255
 a3c:	20 83       	st	Z, r18
		write_size++;
 a3e:	9f 5f       	subi	r25, 0xFF	; 255
 a40:	90 93 84 00 	sts	0x0084, r25
		if(write_pos > UART_RECEIVE_BUFFER_SIZE) 
 a44:	81 32       	cpi	r24, 0x21	; 33
 a46:	10 f0       	brcs	.+4      	; 0xa4c <__vector_13+0x48>
			write_pos = 0;
 a48:	10 92 86 00 	sts	0x0086, r1
		uart_status = UART_BUFFER_OK;
 a4c:	10 92 ba 00 	sts	0x00BA, r1
 a50:	06 c0       	rjmp	.+12     	; 0xa5e <__vector_13+0x5a>
	}
	else {	
		dummy = UDR;
 a52:	8c b1       	in	r24, 0x0c	; 12
 a54:	80 93 89 00 	sts	0x0089, r24
		uart_status = UART_BUFFER_OVERFLOW;
 a58:	81 e0       	ldi	r24, 0x01	; 1
 a5a:	80 93 ba 00 	sts	0x00BA, r24
	}
}
 a5e:	ff 91       	pop	r31
 a60:	ef 91       	pop	r30
 a62:	9f 91       	pop	r25
 a64:	8f 91       	pop	r24
 a66:	2f 91       	pop	r18
 a68:	0f 90       	pop	r0
 a6a:	0f be       	out	0x3f, r0	; 63
 a6c:	0f 90       	pop	r0
 a6e:	1f 90       	pop	r1
 a70:	18 95       	reti

00000a72 <readChar>:
 * // [...]
 *
 */
char readChar(void)
{
	uart_status = UART_BUFFER_OK;
 a72:	10 92 ba 00 	sts	0x00BA, r1
	if(((uint8_t)(write_size - read_size)) > 0) {
 a76:	80 91 85 00 	lds	r24, 0x0085
 a7a:	90 91 84 00 	lds	r25, 0x0084
 a7e:	98 17       	cp	r25, r24
 a80:	a1 f0       	breq	.+40     	; 0xaaa <readChar+0x38>
		read_size++;
 a82:	8f 5f       	subi	r24, 0xFF	; 255
 a84:	80 93 85 00 	sts	0x0085, r24
		if(read_pos > UART_RECEIVE_BUFFER_SIZE) 
 a88:	80 91 87 00 	lds	r24, 0x0087
 a8c:	81 32       	cpi	r24, 0x21	; 33
 a8e:	10 f0       	brcs	.+4      	; 0xa94 <readChar+0x22>
			read_pos = 0;
 a90:	10 92 87 00 	sts	0x0087, r1
		return uart_receive_buffer[read_pos++];
 a94:	e0 91 87 00 	lds	r30, 0x0087
 a98:	81 e0       	ldi	r24, 0x01	; 1
 a9a:	8e 0f       	add	r24, r30
 a9c:	80 93 87 00 	sts	0x0087, r24
 aa0:	f0 e0       	ldi	r31, 0x00	; 0
 aa2:	e5 54       	subi	r30, 0x45	; 69
 aa4:	ff 4f       	sbci	r31, 0xFF	; 255
 aa6:	80 81       	ld	r24, Z
 aa8:	08 95       	ret
	}
	return 0;
 aaa:	80 e0       	ldi	r24, 0x00	; 0
}
 aac:	08 95       	ret

00000aae <readChars>:
 * Just in case that there were fewer chars in the buffer...
 */
uint8_t readChars(char *buf, uint8_t numberOfChars)
{
   uint8_t i = 0;
   uart_status = UART_BUFFER_OK;
 aae:	10 92 ba 00 	sts	0x00BA, r1
 ab2:	28 2f       	mov	r18, r24
   while(((uint8_t)(write_size - read_size))  > 0 && i < numberOfChars) {
 ab4:	fc 01       	movw	r30, r24
 ab6:	8e 2f       	mov	r24, r30
 ab8:	82 1b       	sub	r24, r18
 aba:	90 91 85 00 	lds	r25, 0x0085
 abe:	30 91 84 00 	lds	r19, 0x0084
 ac2:	39 17       	cp	r19, r25
 ac4:	b9 f0       	breq	.+46     	; 0xaf4 <readChars+0x46>
 ac6:	86 17       	cp	r24, r22
 ac8:	a8 f4       	brcc	.+42     	; 0xaf4 <readChars+0x46>
      read_size++;
 aca:	9f 5f       	subi	r25, 0xFF	; 255
 acc:	90 93 85 00 	sts	0x0085, r25
      buf[i++] = uart_receive_buffer[read_pos++];
 ad0:	a0 91 87 00 	lds	r26, 0x0087
 ad4:	81 e0       	ldi	r24, 0x01	; 1
 ad6:	8a 0f       	add	r24, r26
 ad8:	80 93 87 00 	sts	0x0087, r24
 adc:	b0 e0       	ldi	r27, 0x00	; 0
 ade:	a5 54       	subi	r26, 0x45	; 69
 ae0:	bf 4f       	sbci	r27, 0xFF	; 255
 ae2:	8c 91       	ld	r24, X
 ae4:	81 93       	st	Z+, r24
      if(read_pos > UART_RECEIVE_BUFFER_SIZE)
 ae6:	80 91 87 00 	lds	r24, 0x0087
 aea:	81 32       	cpi	r24, 0x21	; 33
 aec:	20 f3       	brcs	.-56     	; 0xab6 <readChars+0x8>
         read_pos = 0;
 aee:	10 92 87 00 	sts	0x0087, r1
 af2:	e1 cf       	rjmp	.-62     	; 0xab6 <readChars+0x8>
   }
   return i;
} 
 af4:	08 95       	ret

00000af6 <getBufferLength>:
 * Example:
 * s. readChar function above!
 */
uint8_t getBufferLength(void)
{
	return (((uint8_t)(write_size - read_size)));
 af6:	80 91 84 00 	lds	r24, 0x0084
 afa:	90 91 85 00 	lds	r25, 0x0085
}
 afe:	89 1b       	sub	r24, r25
 b00:	08 95       	ret

00000b02 <clearReceptionBuffer>:
 * interrupt for a short period of time. 
 */
void clearReceptionBuffer(void)
{
	static uint8_t dummy;
	UCSRB &= ~(1 << RXCIE); // disable UART RX Interrupt
 b02:	57 98       	cbi	0x0a, 7	; 10
	dummy = UDR;
 b04:	8c b1       	in	r24, 0x0c	; 12
 b06:	80 93 88 00 	sts	0x0088, r24
	read_pos = 0;
 b0a:	10 92 87 00 	sts	0x0087, r1
	write_pos = 0; 
 b0e:	10 92 86 00 	sts	0x0086, r1
	read_size = 0;
 b12:	10 92 85 00 	sts	0x0085, r1
	write_size = 0;
 b16:	10 92 84 00 	sts	0x0084, r1
	uart_status = UART_BUFFER_OK;
 b1a:	10 92 ba 00 	sts	0x00BA, r1
	UCSRB |= (1 << RXCIE); // enable Interrupt again
 b1e:	57 9a       	sbi	0x0a, 7	; 10
 b20:	08 95       	ret

00000b22 <I2CTWI_initSlave>:
 * Example:
 * I2CTWI_initSlave((TWI_slaveAddress<<TWI_ADR_BITS) | (TRUE<<TWI_GEN_BIT));  
 */
void I2CTWI_initSlave(uint8_t address)
{
	cli();
 b22:	f8 94       	cli
	TWAR = address;                  // Set own TWI slave address. Accept TWI General Calls.
 b24:	82 b9       	out	0x02, r24	; 2
	TWDR = 0xFF;                     // Default content = SDA released.
 b26:	8f ef       	ldi	r24, 0xFF	; 255
 b28:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWEN);
 b2a:	84 e0       	ldi	r24, 0x04	; 4
 b2c:	86 bf       	out	0x36, r24	; 54
	sei();
 b2e:	78 94       	sei
	// Start the TWI transceiver to enable reception of the first command from the TWI Master.
	TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA);
 b30:	85 ec       	ldi	r24, 0xC5	; 197
 b32:	86 bf       	out	0x36, r24	; 54
 b34:	08 95       	ret

00000b36 <__vector_19>:

volatile uint8_t I2CTWI_readBusy = 0;
volatile uint8_t I2CTWI_writeBusy = 0;

ISR (TWI_vect)
{
 b36:	1f 92       	push	r1
 b38:	0f 92       	push	r0
 b3a:	0f b6       	in	r0, 0x3f	; 63
 b3c:	0f 92       	push	r0
 b3e:	11 24       	eor	r1, r1
 b40:	8f 93       	push	r24
 b42:	ef 93       	push	r30
 b44:	ff 93       	push	r31
	static uint8_t current_register = 0;
	static uint8_t TWI_state = I2CTWI_STATE_IDLE;
	switch (TWSR) {
 b46:	81 b1       	in	r24, 0x01	; 1
 b48:	80 39       	cpi	r24, 0x90	; 144
 b4a:	09 f4       	brne	.+2      	; 0xb4e <__vector_19+0x18>
 b4c:	5e c0       	rjmp	.+188    	; 0xc0a <__vector_19+0xd4>
 b4e:	68 f4       	brcc	.+26     	; 0xb6a <__vector_19+0x34>
 b50:	80 37       	cpi	r24, 0x70	; 112
 b52:	09 f4       	brne	.+2      	; 0xb56 <__vector_19+0x20>
 b54:	56 c0       	rjmp	.+172    	; 0xc02 <__vector_19+0xcc>
 b56:	80 38       	cpi	r24, 0x80	; 128
 b58:	d9 f1       	breq	.+118    	; 0xbd0 <__vector_19+0x9a>
 b5a:	80 36       	cpi	r24, 0x60	; 96
 b5c:	09 f0       	breq	.+2      	; 0xb60 <__vector_19+0x2a>
 b5e:	5a c0       	rjmp	.+180    	; 0xc14 <__vector_19+0xde>
			I2CTWI_readBusy = 0;	
			I2CTWI_dataWasRead = 1;
			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA);
		break;
		case TWI_SRX_ADR_ACK: // Own SLA+W has been received ACK has been returned
			I2CTWI_writeBusy = 1;
 b60:	81 e0       	ldi	r24, 0x01	; 1
 b62:	80 93 8a 00 	sts	0x008A, r24
			TWI_state = I2CTWI_STATE_WRITE_REG;	
 b66:	82 e0       	ldi	r24, 0x02	; 2
 b68:	4d c0       	rjmp	.+154    	; 0xc04 <__vector_19+0xce>

ISR (TWI_vect)
{
	static uint8_t current_register = 0;
	static uint8_t TWI_state = I2CTWI_STATE_IDLE;
	switch (TWSR) {
 b6a:	88 3a       	cpi	r24, 0xA8	; 168
 b6c:	d9 f0       	breq	.+54     	; 0xba4 <__vector_19+0x6e>
 b6e:	58 f4       	brcc	.+22     	; 0xb86 <__vector_19+0x50>
 b70:	80 3a       	cpi	r24, 0xA0	; 160
 b72:	09 f0       	breq	.+2      	; 0xb76 <__vector_19+0x40>
 b74:	4f c0       	rjmp	.+158    	; 0xc14 <__vector_19+0xde>
		case TWI_SRX_GEN_DATA_ACK: // Previously addressed with general call; data has been received; ACK has been returned
			I2CTWI_genCallCMD = TWDR;
			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA); // Send ACK after next reception
	    break;
		case TWI_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave
			TWI_state = I2CTWI_STATE_REP_START;
 b76:	85 e0       	ldi	r24, 0x05	; 5
 b78:	80 93 8f 00 	sts	0x008F, r24
			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA);
 b7c:	85 ec       	ldi	r24, 0xC5	; 197
 b7e:	86 bf       	out	0x36, r24	; 54
			I2CTWI_writeBusy = 0;
 b80:	10 92 8a 00 	sts	0x008A, r1
		break;
 b84:	49 c0       	rjmp	.+146    	; 0xc18 <__vector_19+0xe2>

ISR (TWI_vect)
{
	static uint8_t current_register = 0;
	static uint8_t TWI_state = I2CTWI_STATE_IDLE;
	switch (TWSR) {
 b86:	88 3b       	cpi	r24, 0xB8	; 184
 b88:	99 f0       	breq	.+38     	; 0xbb0 <__vector_19+0x7a>
 b8a:	80 3c       	cpi	r24, 0xC0	; 192
 b8c:	09 f0       	breq	.+2      	; 0xb90 <__vector_19+0x5a>
 b8e:	42 c0       	rjmp	.+132    	; 0xc14 <__vector_19+0xde>
			if(TWI_state == I2CTWI_STATE_READ_REG)
				TWDR = I2CTWI_readRegisters[current_register++];
			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA); // Enable TWI Interupt and clear the flag to send byte
		break;
		case TWI_STX_DATA_NACK: // Data byte in TWDR has been transmitted; NACK has been received.
			TWI_state = I2CTWI_STATE_IDLE; // ... this is most likely the end of the transmission.
 b90:	10 92 8f 00 	sts	0x008F, r1
			current_register = 0;
 b94:	10 92 8e 00 	sts	0x008E, r1
			I2CTWI_readBusy = 0;	
 b98:	10 92 8b 00 	sts	0x008B, r1
			I2CTWI_dataWasRead = 1;
 b9c:	81 e0       	ldi	r24, 0x01	; 1
 b9e:	80 93 8d 00 	sts	0x008D, r24
 ba2:	36 c0       	rjmp	.+108    	; 0xc10 <__vector_19+0xda>
{
	static uint8_t current_register = 0;
	static uint8_t TWI_state = I2CTWI_STATE_IDLE;
	switch (TWSR) {
		case TWI_STX_ADR_ACK:   // Own SLA+R has been received; ACK has been returned
			TWI_state = I2CTWI_STATE_READ_REG;				
 ba4:	84 e0       	ldi	r24, 0x04	; 4
 ba6:	80 93 8f 00 	sts	0x008F, r24
			I2CTWI_readBusy = 1;		
 baa:	81 e0       	ldi	r24, 0x01	; 1
 bac:	80 93 8b 00 	sts	0x008B, r24
		case TWI_STX_DATA_ACK:  // Data byte in TWDR has been transmitted; ACK has been received
			if(TWI_state == I2CTWI_STATE_READ_REG)
 bb0:	80 91 8f 00 	lds	r24, 0x008F
 bb4:	84 30       	cpi	r24, 0x04	; 4
 bb6:	61 f5       	brne	.+88     	; 0xc10 <__vector_19+0xda>
				TWDR = I2CTWI_readRegisters[current_register++];
 bb8:	e0 91 8e 00 	lds	r30, 0x008E
 bbc:	81 e0       	ldi	r24, 0x01	; 1
 bbe:	8e 0f       	add	r24, r30
 bc0:	80 93 8e 00 	sts	0x008E, r24
 bc4:	f0 e0       	ldi	r31, 0x00	; 0
 bc6:	e3 51       	subi	r30, 0x13	; 19
 bc8:	ff 4f       	sbci	r31, 0xFF	; 255
 bca:	80 81       	ld	r24, Z
 bcc:	83 b9       	out	0x03, r24	; 3
 bce:	20 c0       	rjmp	.+64     	; 0xc10 <__vector_19+0xda>
			I2CTWI_writeBusy = 1;
			TWI_state = I2CTWI_STATE_WRITE_REG;	
			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA); // Reset the TWI Interupt to wait for a new event.	
		break;
		case TWI_SRX_ADR_DATA_ACK: // Previously addressed with own SLA+W; data has been received; ACK has been returned
			if(TWI_state == I2CTWI_STATE_WRITE_REG) {
 bd0:	80 91 8f 00 	lds	r24, 0x008F
 bd4:	82 30       	cpi	r24, 0x02	; 2
 bd6:	39 f4       	brne	.+14     	; 0xbe6 <__vector_19+0xb0>
				current_register = TWDR;
 bd8:	83 b1       	in	r24, 0x03	; 3
 bda:	80 93 8e 00 	sts	0x008E, r24
				I2CTWI_dataReadFromReg = current_register;
 bde:	80 93 8c 00 	sts	0x008C, r24
				TWI_state = I2CTWI_STATE_WRITE_DATA;
 be2:	83 e0       	ldi	r24, 0x03	; 3
 be4:	0f c0       	rjmp	.+30     	; 0xc04 <__vector_19+0xce>
			}
			else if(TWI_state == I2CTWI_STATE_WRITE_DATA)
 be6:	83 30       	cpi	r24, 0x03	; 3
 be8:	99 f4       	brne	.+38     	; 0xc10 <__vector_19+0xda>
				I2CTWI_writeRegisters[current_register++] = TWDR;
 bea:	e0 91 8e 00 	lds	r30, 0x008E
 bee:	81 e0       	ldi	r24, 0x01	; 1
 bf0:	8e 0f       	add	r24, r30
 bf2:	80 93 8e 00 	sts	0x008E, r24
 bf6:	f0 e0       	ldi	r31, 0x00	; 0
 bf8:	83 b1       	in	r24, 0x03	; 3
 bfa:	e3 52       	subi	r30, 0x23	; 35
 bfc:	ff 4f       	sbci	r31, 0xFF	; 255
 bfe:	80 83       	st	Z, r24
 c00:	07 c0       	rjmp	.+14     	; 0xc10 <__vector_19+0xda>
			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA); // Reset the TWI Interupt to wait for a new event, send ACK after next reception
		break;
		case TWI_SRX_GEN_ACK: // General call address has been received; ACK has been returned
			TWI_state = I2CTWI_STATE_GEN_CALL;
 c02:	81 e0       	ldi	r24, 0x01	; 1
 c04:	80 93 8f 00 	sts	0x008F, r24
 c08:	03 c0       	rjmp	.+6      	; 0xc10 <__vector_19+0xda>
			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA);
		break;
		case TWI_SRX_GEN_DATA_ACK: // Previously addressed with general call; data has been received; ACK has been returned
			I2CTWI_genCallCMD = TWDR;
 c0a:	83 b1       	in	r24, 0x03	; 3
 c0c:	80 93 dc 00 	sts	0x00DC, r24
			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA); // Send ACK after next reception
 c10:	85 ec       	ldi	r24, 0xC5	; 197
 c12:	01 c0       	rjmp	.+2      	; 0xc16 <__vector_19+0xe0>
			TWI_state = I2CTWI_STATE_REP_START;
			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA);
			I2CTWI_writeBusy = 0;
		break;
		default: // Any error, no state etc. 
			TWCR = (1<<TWEN)|(1<<TWINT); 
 c14:	84 e8       	ldi	r24, 0x84	; 132
 c16:	86 bf       	out	0x36, r24	; 54
		break;
	}
}
 c18:	ff 91       	pop	r31
 c1a:	ef 91       	pop	r30
 c1c:	8f 91       	pop	r24
 c1e:	0f 90       	pop	r0
 c20:	0f be       	out	0x3f, r0	; 63
 c22:	0f 90       	pop	r0
 c24:	1f 90       	pop	r1
 c26:	18 95       	reti

00000c28 <main>:

#define slaveAddress 12

int main(void)
{
	initRP6Control(); 	
 c28:	0e 94 3c 04 	call	0x878	; 0x878 <initRP6Control>
	I2CTWI_initSlave(slaveAddress);
 c2c:	8c e0       	ldi	r24, 0x0C	; 12
 c2e:	0e 94 91 05 	call	0xb22	; 0xb22 <I2CTWI_initSlave>

	uint8_t sideHit = 0;
	uint8_t timesPressed2 = 0;
	
	DDRC &= ~IO_PC3; 
 c32:	a3 98       	cbi	0x14, 3	; 20
	PORTC &= ~IO_PC3; 
 c34:	ab 98       	cbi	0x15, 3	; 21

	if(PINC & IO_PC3) // Check if PC6 is high
 c36:	9b 9b       	sbis	0x13, 3	; 19
 c38:	03 c0       	rjmp	.+6      	; 0xc40 <main+0x18>
		writeString_P("\n\nPC3 is HIGH!\n\n");
 c3a:	84 e6       	ldi	r24, 0x64	; 100
 c3c:	90 e0       	ldi	r25, 0x00	; 0
 c3e:	02 c0       	rjmp	.+4      	; 0xc44 <main+0x1c>
	else
		writeString_P("\n\nPC3 is LOW!\n\n");
 c40:	84 e5       	ldi	r24, 0x54	; 84
 c42:	90 e0       	ldi	r25, 0x00	; 0
 c44:	0e 94 79 04 	call	0x8f2	; 0x8f2 <writeNStringP>
#include "RP6I2CslaveTWI.h"

#define slaveAddress 12

int main(void)
{
 c48:	80 e0       	ldi	r24, 0x00	; 0
 c4a:	90 e0       	ldi	r25, 0x00	; 0
 c4c:	c0 e0       	ldi	r28, 0x00	; 0

	int lastButton3State = false;

	while(true)
	{
		if((PINC & IO_PC3) !=  lastButton3State)
 c4e:	23 b3       	in	r18, 0x13	; 19
 c50:	28 70       	andi	r18, 0x08	; 8
 c52:	30 e0       	ldi	r19, 0x00	; 0
 c54:	28 17       	cp	r18, r24
 c56:	39 07       	cpc	r19, r25
 c58:	a1 f0       	breq	.+40     	; 0xc82 <main+0x5a>
		{
			if(PINC & IO_PC3)
 c5a:	9b 9b       	sbis	0x13, 3	; 19
 c5c:	12 c0       	rjmp	.+36     	; 0xc82 <main+0x5a>
			{
				sideHit = 2;
				timesPressed2++;
 c5e:	cf 5f       	subi	r28, 0xFF	; 255
				writeString("Button 2 pressed ");
 c60:	86 e6       	ldi	r24, 0x66	; 102
 c62:	90 e0       	ldi	r25, 0x00	; 0
 c64:	0e 94 6d 04 	call	0x8da	; 0x8da <writeString>
				writeInteger(timesPressed2, DEC);
 c68:	6a e0       	ldi	r22, 0x0A	; 10
 c6a:	8c 2f       	mov	r24, r28
 c6c:	90 e0       	ldi	r25, 0x00	; 0
 c6e:	0e 94 a5 04 	call	0x94a	; 0x94a <writeInteger>
				writeString(" times.");
 c72:	88 e7       	ldi	r24, 0x78	; 120
 c74:	90 e0       	ldi	r25, 0x00	; 0
 c76:	0e 94 6d 04 	call	0x8da	; 0x8da <writeString>
				writeString("\n");
 c7a:	80 e8       	ldi	r24, 0x80	; 128
 c7c:	90 e0       	ldi	r25, 0x00	; 0
 c7e:	0e 94 6d 04 	call	0x8da	; 0x8da <writeString>
			}
		}	

		lastButton3State = PINC & IO_PC3;
 c82:	83 b3       	in	r24, 0x13	; 19
 c84:	88 70       	andi	r24, 0x08	; 8
 c86:	90 e0       	ldi	r25, 0x00	; 0
	}	
 c88:	e2 cf       	rjmp	.-60     	; 0xc4e <main+0x26>

00000c8a <itoa>:
 c8a:	fb 01       	movw	r30, r22
 c8c:	9f 01       	movw	r18, r30
 c8e:	e8 94       	clt
 c90:	42 30       	cpi	r20, 0x02	; 2
 c92:	c4 f0       	brlt	.+48     	; 0xcc4 <itoa+0x3a>
 c94:	45 32       	cpi	r20, 0x25	; 37
 c96:	b4 f4       	brge	.+44     	; 0xcc4 <itoa+0x3a>
 c98:	4a 30       	cpi	r20, 0x0A	; 10
 c9a:	29 f4       	brne	.+10     	; 0xca6 <itoa+0x1c>
 c9c:	97 fb       	bst	r25, 7
 c9e:	1e f4       	brtc	.+6      	; 0xca6 <itoa+0x1c>
 ca0:	90 95       	com	r25
 ca2:	81 95       	neg	r24
 ca4:	9f 4f       	sbci	r25, 0xFF	; 255
 ca6:	64 2f       	mov	r22, r20
 ca8:	77 27       	eor	r23, r23
 caa:	0e 94 76 06 	call	0xcec	; 0xcec <__udivmodhi4>
 cae:	80 5d       	subi	r24, 0xD0	; 208
 cb0:	8a 33       	cpi	r24, 0x3A	; 58
 cb2:	0c f0       	brlt	.+2      	; 0xcb6 <itoa+0x2c>
 cb4:	89 5d       	subi	r24, 0xD9	; 217
 cb6:	81 93       	st	Z+, r24
 cb8:	cb 01       	movw	r24, r22
 cba:	00 97       	sbiw	r24, 0x00	; 0
 cbc:	a1 f7       	brne	.-24     	; 0xca6 <itoa+0x1c>
 cbe:	16 f4       	brtc	.+4      	; 0xcc4 <itoa+0x3a>
 cc0:	5d e2       	ldi	r21, 0x2D	; 45
 cc2:	51 93       	st	Z+, r21
 cc4:	10 82       	st	Z, r1
 cc6:	c9 01       	movw	r24, r18
 cc8:	0c 94 66 06 	jmp	0xccc	; 0xccc <strrev>

00000ccc <strrev>:
 ccc:	dc 01       	movw	r26, r24
 cce:	fc 01       	movw	r30, r24
 cd0:	67 2f       	mov	r22, r23
 cd2:	71 91       	ld	r23, Z+
 cd4:	77 23       	and	r23, r23
 cd6:	e1 f7       	brne	.-8      	; 0xcd0 <strrev+0x4>
 cd8:	32 97       	sbiw	r30, 0x02	; 2
 cda:	04 c0       	rjmp	.+8      	; 0xce4 <strrev+0x18>
 cdc:	7c 91       	ld	r23, X
 cde:	6d 93       	st	X+, r22
 ce0:	70 83       	st	Z, r23
 ce2:	62 91       	ld	r22, -Z
 ce4:	ae 17       	cp	r26, r30
 ce6:	bf 07       	cpc	r27, r31
 ce8:	c8 f3       	brcs	.-14     	; 0xcdc <strrev+0x10>
 cea:	08 95       	ret

00000cec <__udivmodhi4>:
 cec:	aa 1b       	sub	r26, r26
 cee:	bb 1b       	sub	r27, r27
 cf0:	51 e1       	ldi	r21, 0x11	; 17
 cf2:	07 c0       	rjmp	.+14     	; 0xd02 <__udivmodhi4_ep>

00000cf4 <__udivmodhi4_loop>:
 cf4:	aa 1f       	adc	r26, r26
 cf6:	bb 1f       	adc	r27, r27
 cf8:	a6 17       	cp	r26, r22
 cfa:	b7 07       	cpc	r27, r23
 cfc:	10 f0       	brcs	.+4      	; 0xd02 <__udivmodhi4_ep>
 cfe:	a6 1b       	sub	r26, r22
 d00:	b7 0b       	sbc	r27, r23

00000d02 <__udivmodhi4_ep>:
 d02:	88 1f       	adc	r24, r24
 d04:	99 1f       	adc	r25, r25
 d06:	5a 95       	dec	r21
 d08:	a9 f7       	brne	.-22     	; 0xcf4 <__udivmodhi4_loop>
 d0a:	80 95       	com	r24
 d0c:	90 95       	com	r25
 d0e:	bc 01       	movw	r22, r24
 d10:	cd 01       	movw	r24, r26
 d12:	08 95       	ret

00000d14 <_exit>:
 d14:	f8 94       	cli

00000d16 <__stop_program>:
 d16:	ff cf       	rjmp	.-2      	; 0xd16 <__stop_program>
